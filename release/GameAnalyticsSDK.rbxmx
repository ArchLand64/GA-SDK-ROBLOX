<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
    <External>null</External>
    <External>nil</External>
    <Item class="ModuleScript" referent="RBXf309a3c5773d40eaae7007cb4478e182">
        <Properties>
            <Content name="LinkedSource"><null></null></Content>
            <string name="Name">GameAnalyticsSDK</string>
            <string name="ScriptGuid">{7431f9d9-7538-46e6-a8c6-45d71ee7e57a}</string>
            <ProtectedString name="Source"><![CDATA[local module = {}
return module
]]></ProtectedString>
            <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="Script" referent="RBXa82cd927306847a28e2acd9083a050b2">
            <Properties>
                <bool name="Disabled">false</bool>
                <Content name="LinkedSource"><null></null></Content>
                <string name="Name">GameAnalyticsServer</string>
                <string name="ScriptGuid">{4efacb9d-efec-45dc-892a-1ddedb9a9ae3}</string>
                <ProtectedString name="Source"><![CDATA[--[[

    NOTE: This script should be in game.ServerScriptService

--]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")

--Validate
if not script:IsDescendantOf(game:GetService("ServerScriptService")) then
    error("GameAnalytics: Disabled server. GameAnalyticsServer has to be located in game.ServerScriptService.")
    return
end

-- if not ReplicatedStorage:FindFirstChild("GameAnalyticsSendMessage") then
--     --Create
--     local f = Instance.new("RemoteEvent")
--     f.Name = "GameAnalyticsSendMessage"
--     f.Parent = ReplicatedStorage
-- end

if not ReplicatedStorage:FindFirstChild("GameAnalyticsCommandCenter") then
    --Create
    local f = Instance.new("RemoteEvent")
    f.Name = "GameAnalyticsCommandCenter"
    f.Parent = ReplicatedStorage
end

--Modules
local GameAnalytics = require(ServerStorage.GameAnalytics)
local store = require(ServerStorage.GameAnalytics.Store)
local state = require(ServerStorage.GameAnalytics.State)
local LS = game:GetService("LogService")
local MKT = game:GetService("MarketplaceService")
local Players = game:GetService("Players")
local ProductCache = {}
local ONE_HOUR_IN_SECONDS = 3600
local MaxErrorsPerHour = 10
local ErrorDS = {}
local errorCountCache = {}
local errorCountCacheKeys = {}

spawn(function()
    local currentHour = math.floor(os.time()/3600)
    ErrorDS = store:GetErrorDataStore(currentHour)

    while wait(ONE_HOUR_IN_SECONDS) do
        currentHour = math.floor(os.time()/3600)
        ErrorDS = store:GetErrorDataStore(currentHour)
        errorCountCache = {}
        errorCountCacheKeys = {}
    end
end)

spawn(function()
    while wait(store.AutoSaveData) do
        for _, key in pairs(errorCountCacheKeys) do
            local errorCount = errorCountCache[key]
            local step = errorCount.currentCount - errorCount.countInDS
            errorCountCache[key].countInDS = store:IncrementErrorCount(ErrorDS, key, step)
            errorCountCache[key].currentCount = errorCountCache[key].countInDS
        end
    end
end)

--Error Logging
LS.MessageOut:Connect(function(message, messageType)

    --Validate
    if not state.ReportErrors then
        return
    end
    if messageType ~= Enum.MessageType.MessageError then
        return
    end

    local m = message
    if #m > 8192 then
        m = string.sub(m, 1, 8192)
    end

    local key = m
    if #key > 50 then
        key = string.sub(key, 1, 50)
    end

    if errorCountCache[key] == nil then
        errorCountCacheKeys[#errorCountCacheKeys + 1] = key
        errorCountCache[key] = {}
        errorCountCache[key].countInDS = 0
        errorCountCache[key].currentCount = 0
    end

    -- don't report error if limit has been exceeded
    if errorCountCache[key].currentCount > MaxErrorsPerHour then
        return
    end

    --Report (use nil for playerId as real player id is not available)
    GameAnalytics:addErrorEvent(nil, {
        severity = GameAnalytics.EGAErrorSeverity.error,
        message = m
    })

    -- increment error count
    errorCountCache[key].currentCount = errorCountCache[key].currentCount + 1
end)

--Record Gamepasses. NOTE: This doesn't record gamepass purchases if a player buys it from the website
MKT.PromptGamePassPurchaseFinished:Connect(function(Player, ID, Purchased)

    --Validate
    if not state.AutomaticSendBusinessEvents then
        return
    end

    --Validate
    if not Purchased then return end

    --Variables
    local GamepassInfo = ProductCache[ID]

    --Cache
    if not GamepassInfo then

        --Get
        GamepassInfo = MKT:GetProductInfo(ID, Enum.InfoType.GamePass)
        ProductCache[ID] = GamepassInfo
    end

    GameAnalytics:addBusinessEvent(Player.UserId, {
        amount = GamepassInfo.PriceInRobux,
        itemType = "Gamepass",
        itemId = GamepassInfo.Name
    })
end)

-- Fire for players already in game
for _, Player in pairs(Players:GetPlayers()) do
    GameAnalytics:PlayerJoined(Player)
end

-- New Players
Players.PlayerAdded:Connect(function(Player)
    local joinData = Player:GetJoinData()
    local teleportData = joinData.TeleportData
    local gaData = nil
    if teleportData then
        gaData = teleportData.gameanalyticsData and teleportData.gameanalyticsData[tostring(Player.UserId)]
    end
    GameAnalytics:PlayerJoined(Player, gaData)
end)

-- Players leaving
Players.PlayerRemoving:Connect(function(Player)
    GameAnalytics:PlayerRemoved(Player)
end)
]]></ProtectedString>
                <BinaryString name="Tags"></BinaryString>
            </Properties>
        </Item>
        <Item class="ModuleScript" referent="RBXa82cd927306847a28e2acd9083a990b2">
            <Properties>
                <bool name="Disabled">false</bool>
                <Content name="LinkedSource"><null></null></Content>
                <string name="Name">Postie</string>
                <string name="ScriptGuid">{4efacb9d-efec-45dc-892a-1ddedb9a9ae9}</string>
                <ProtectedString name="Source"><![CDATA[--[[
    Postie - An elegant alternative to RemoteFunctions with a timeout
    By Dandystan

    INTERFACE:

        Function bool, Tuple Postie.InvokeClient(string id, Instance<Player> player, number timeout, Tuple args) [server_side] [yields]
         Invoke player with arguments args. Invocation identified by id. Yield until timeout (given in seconds) is reached
         and return false, or a signal is received back from the client and return true plus any values received from the
         client.

        Function bool, Tuple Postie.InvokeServer(string id, number timeout, Tuple args) [client_side] [yields]
         Invoke the server with arguments args. Invocation identified by id. Yield until timeout (given in seconds) is
         reached and return false, or a signal is received back from the server and return true plus any values received
         from the server.

        Function void Postie.SetCallback(string id, func callback)
         Set the callback that is invoked when an invocation identified by id is sent. Arguments passed with the invocation
         are passed to the callback. If on the server, the player who invoked is implicitly received as the first argument.

        Function func? Postie.GetCallback(string id)
         Return the callback associated with id.

    EXAMPLE 1 - server to client:

        Server:
            local postie = require(postieObj)

            -- arbritary func to be called whenever
            local function getTrampolinesOnScreen(player)
                -- get objects on screen from player
                local isSuccessful, trampolines = postie.InvokeClient("RequestObjectsOnScreen", player, 5, "Trampolines")
                -- check for timeout
                if isSuccessful then
                    -- validate returned data type for security purposes
                    if typeof(trampolines) == "number" then
                        return true, trampolines
                    end
                end

                return false
            end

        Client:
            local postie = require(postieObj)

            postie.SetCallback("RequestObjectsOnScreen", function(objectType)
                return objectsOnScreen[objectType]
            end)

    EXAMPLE 2 - client to server:

        Server:
            local postie = require(postieObj)

            postie.SetCallback("GetCoins", function(player)
                return playerCoins[player]
            end)

        Client:
            local postie = require(postieObj)

            local function getCoins()
                return postie.InvokeServer("GetCoins", 5)
            end
--]]

-- services:
local runService = game:GetService("RunService")

if not script:FindFirstChild("Sent") then
    --Create
    local f = Instance.new("RemoteEvent")
    f.Name = "Sent"
    f.Parent = script
end

if not script:FindFirstChild("Received") then
    --Create
    local f = Instance.new("RemoteEvent")
    f.Name = "Received"
    f.Parent = script
end

-- variables:
local sent = script.Sent
local received = script.Received
local isServer = runService:IsServer()
local idCallbacks = {}
local listeners = {}
local signalVersion = 1


-- Postie:
local postie = {}

function postie.InvokeClient(id, player, timeout, ...)
    assert(isServer, "Postie.InvokeClient can only be called from the server")
    assert(typeof(id) == "string", "bad argument #1 to Postie.InvokeClient, expects string")
    assert(typeof(player) == "Instance" and player:IsA("Player"), "bad argument #2 to Postie.InvokeClient, expects Instance<Player>")
    assert(typeof(timeout) == "number", "bad argument #3 to Postie.InvokeClient, expects number")

    -- define variables
    local thread = coroutine.running()
    local isResumed = false
    local pos = #listeners + 1
    -- get signal version
    local version = signalVersion
    signalVersion = signalVersion + 1
    -- await signal from client
    listeners[pos] = function(playerWhoFired, versionOfSignal, ...)
        if not (playerWhoFired == player and versionOfSignal == version) then return end
        isResumed = true
        table.remove(listeners, pos)
        coroutine.resume(thread, true, ...)

        return true
    end
    -- await timeout
    coroutine.wrap(function()
        wait(timeout)
        if isResumed then return end
        table.remove(listeners, pos)
        coroutine.resume(thread, false)
    end)()
    -- send signal
    sent:FireClient(player, id, version, ...)

    return coroutine.yield()
end

function postie.InvokeServer(id, timeout, ...)
    assert(not isServer, "Postie.InvokeServer can only be called from the client")
    assert(typeof(id) == "string", "bad argument #1 to Postie.InvokeServer, expects string")
    assert(typeof(timeout) == "number", "bad argument #2 to Postie.InvokeServer, expects number")

    -- define variables
    local thread = coroutine.running()
    local isResumed = false
    local pos = #listeners + 1
    -- get signal version
    local version = signalVersion
    signalVersion = signalVersion + 1
    -- await signal from client
    listeners[pos] = function(versionOfSignal, ...)
        if versionOfSignal ~= id then return end
        isResumed = true
        table.remove(listeners, pos)
        coroutine.resume(thread, true, ...)

        return true
    end
    -- await timeout
    coroutine.wrap(function()
        wait(timeout)
        if isResumed then return end
        table.remove(listeners, pos)
        coroutine.resume(thread, false)
    end)()
    -- send signal
    sent:FireServer(id, version, ...)

    return coroutine.yield()
end

function postie.SetCallback(id, callback)
    assert(typeof(id) == "string", "bad argument #1 to Postie.SetCallback, expects string")
    assert(typeof(callback) == "function", "bad argument #2 to Postie.SetCallback, expects func")

    idCallbacks[id] = callback
end

function postie.GetCallback(id)
    assert(typeof(id) == "string", "bad argument #1 to Postie.GetCallback, expects string")

    return idCallbacks[id]
end


-- main:
-- handle signals
if isServer then
    -- handle received
    received.OnServerEvent:Connect(function(...)
        for _, listener in ipairs(listeners) do
            if listener(...) then return end
        end
    end)
    -- handle sent
    sent.OnServerEvent:Connect(function(player, id, version, ...)
        local callback = idCallbacks[id]
        received:FireClient(player, version, callback and callback(player, ...))
    end)
else
    -- handle received
    received.OnClientEvent:Connect(function(...)
        for _, listener in ipairs(listeners) do
            if listener(...) then return end
        end
    end)
    -- handle sent
    sent.OnClientEvent:Connect(function(id, version, ...)
        local callback = idCallbacks[id]
        received:FireServer(version, callback and callback(...))
    end)
end

return postie
]]></ProtectedString>
                <BinaryString name="Tags"></BinaryString>
            </Properties>
        </Item>
        <Item class="Script" referent="RBXa82cd927306847a28e2acd9083a150a5">
            <Properties>
                <bool name="Disabled">false</bool>
                <Content name="LinkedSource"><null></null></Content>
                <string name="Name">GameAnalyticsServerInitUsingSettings</string>
                <string name="ScriptGuid">{4efacb9d-efec-45dc-892a-1ddedb9a9ae3}</string>
                <ProtectedString name="Source"><![CDATA[--[[

    NOTE: This script should be in game.ServerScriptService

--]]

local ServerStorage = game:GetService("ServerStorage")

--Validate
if not script:IsDescendantOf(game:GetService("ServerScriptService")) then
    error("GameAnalytics: GameAnalyticsServerInitUsingSettings has to be located in game.ServerScriptService.")
    return
end

--Modules
local GameAnalytics = require(ServerStorage.GameAnalytics)
local Settings = require(ServerStorage.GameAnalytics.Settings)
local Players = game:GetService("Players")

if Settings.EnableInfoLog then
    GameAnalytics:setEnabledInfoLog(Settings.EnableInfoLog)
end
if Settings.EnableVerboseLog then
    GameAnalytics:setEnabledVerboseLog(Settings.EnableVerboseLog)
end

if #Settings.AvailableCustomDimensions01 > 0 then
    GameAnalytics:configureAvailableCustomDimensions01(Settings.AvailableCustomDimensions01)
end
if #Settings.AvailableCustomDimensions02 > 0 then
    GameAnalytics:configureAvailableCustomDimensions02(Settings.AvailableCustomDimensions02)
end
if #Settings.AvailableCustomDimensions03 > 0 then
    GameAnalytics:configureAvailableCustomDimensions03(Settings.AvailableCustomDimensions03)
end
if #Settings.AvailableResourceCurrencies > 0 then
    GameAnalytics:configureAvailableResourceCurrencies(Settings.AvailableResourceCurrencies)
end
if #Settings.AvailableResourceItemTypes > 0 then
    GameAnalytics:configureAvailableResourceItemTypes(Settings.AvailableResourceItemTypes)
end
if #Settings.Build > 0 then
    GameAnalytics:configureBuild(Settings.Build)
end

GameAnalytics:initialize({
    gameKey = Settings.GameKey,
    secretKey = Settings.SecretKey
})

-- Fire for players already in game
for _, Player in pairs(Players:GetPlayers()) do
    GameAnalytics:PlayerJoined(Player)
end
]]></ProtectedString>
                <BinaryString name="Tags"></BinaryString>
            </Properties>
        </Item>
        <Item class="Script" referent="RBXb7b6780e3b3b47999e926fea38fa454f">
            <Properties>
                <bool name="Disabled">false</bool>
                <Content name="LinkedSource"><null></null></Content>
                <string name="Name">INSTALL</string>
                <string name="ScriptGuid">{4efacb9d-efec-45dc-892a-1ddedb9a2ae1}</string>
                <ProtectedString name="Source"><![CDATA[--[[

Thanks for using the official GameAnalytics Roblox SDK module (based on gillern's GameAnalytics module)!

To start using the plugin, follow these steps:

1. Create an account on gameanalytics.com and create a game
2. Get your game key and secret key
3. Add the keys to 'GameKey' and 'SecretKey' under GameAnalytics.Settings script
4. Move the 'GameAnalytics' script (together with its children) under 'ServerStorage'
5. Move the 'GameAnalyticsServer' script under 'ServerScriptService'
6. Move the 'GameAnalyticsServerInitUsingSettings' script under 'ServerScriptService' (optional, NOT needed if you want to programmatically initialize the SDK from your own script)
7. Move the 'GameAnalyticsClient' script under 'StarterPlayer/StarerPlayerScripts'
8. Move the 'Postie' script under 'ReplicatedStorage'
9. You're ready!

NOTE: The provided rojo.json in the repository is set up to perform steps 4, 5 and 6 automatically through the Rojo workflow.

For details on how to send events and more with the SDK go to this page: https://gameanalytics.com/docs/item/roblox-sdk

Resources:
    Roblox SDK Docs: https://gameanalytics.com/docs/item/roblox-sdk
    Github: https://github.com/GameAnalytics/GA-SDK-ROBLOX
    Account sign up: https://go.gameanalytics.com/signup
    Support: https://gameanalytics.com/contact

--]]
]]></ProtectedString>
                <BinaryString name="Tags"></BinaryString>
            </Properties>
        </Item>
        <Item class="LocalScript" referent="RBX5ddcab423f9e430186a33c70b93fc965">
            <Properties>
                <bool name="Disabled">false</bool>
                <Content name="LinkedSource"><null></null></Content>
                <string name="Name">GameAnalyticsClient</string>
                <string name="ScriptGuid">{7cd38da4-97aa-470d-a875-cace696c90ba}</string>
                <ProtectedString name="Source"><![CDATA[--Variables
--local GameAnalyticsSendMessage = game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")

--Services
local GS = game:GetService("GuiService")
local UIS = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Postie = require(ReplicatedStorage.Postie)

--Functions
local function getPlatform()

    if (GS:IsTenFootInterface()) then
        return "Console"
    elseif (UIS.TouchEnabled and not UIS.MouseEnabled) then
        return "Mobile"
    else
        return "Desktop"
    end
end

--Filtering
Postie.SetCallback("getPlatform", getPlatform);

-- debug stuff
--GameAnalyticsSendMessage.OnClientEvent:Connect(function(chatProperties)
--    game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", chatProperties)
--end)
]]></ProtectedString>
                <BinaryString name="Tags"></BinaryString>
            </Properties>
        </Item>
        <Item class="ModuleScript" referent="RBXf8708688395b460f9941544945f03ab9">
            <Properties>
                <Content name="LinkedSource"><null></null></Content>
                <string name="Name">GameAnalytics</string>
                <string name="ScriptGuid"></string>
                <ProtectedString name="Source"><![CDATA[local GAResourceFlowType = require(script.GAResourceFlowType)
local GAProgressionStatus = require(script.GAProgressionStatus)
local GAErrorSeverity = require(script.GAErrorSeverity)

local ga = {
    EGAResourceFlowType = GAResourceFlowType,
    EGAProgressionStatus = GAProgressionStatus,
    EGAErrorSeverity = GAErrorSeverity
}

local logger = require(script.Logger)
local threading = require(script.Threading)
local state = require(script.State)
local validation = require(script.Validation)
local store = require(script.Store)
local events = require(script.Events)
local Players = game:GetService("Players")
local MKT = game:GetService("MarketplaceService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Postie = require(ReplicatedStorage.Postie)
local ProductCache = {}


-- local functions
local function isSdkReady(options)
    local playerId = options["playerId"] or nil
    local needsInitialized = options["needsInitialized"] or true
    local shouldWarn = options["shouldWarn"] or false
    local message = options["message"] or ""

    -- Is SDK initialized
    if needsInitialized and not state.Initialized then
        if shouldWarn then
            logger:w(message .. " SDK is not initialized")
        end
        return false
    end

    -- Is SDK enabled
    if needsInitialized and playerId and not state:isEnabled(playerId) then
        if shouldWarn then
            logger:w(message .. " SDK is disabled")
        end
        return false
    end

    -- Is session started
    if needsInitialized and playerId and not state:sessionIsStarted(playerId) then
        if shouldWarn then
            logger:w(message .. " Session has not started yet")
        end
        return false
    end

    return true
end

function ga:configureAvailableCustomDimensions01(customDimensions)
    threading:performTaskOnGAThread(function()
        if isSdkReady({needsInitialized=true, shouldWarn=false}) then
            logger:w("Available custom dimensions must be set before SDK is initialized")
            return
        end

        state:setAvailableCustomDimensions01(customDimensions)
    end)
end

function ga:configureAvailableCustomDimensions02(customDimensions)
    threading:performTaskOnGAThread(function()
        if isSdkReady({needsInitialized=true, shouldWarn=false}) then
            logger:w("Available custom dimensions must be set before SDK is initialized")
            return
        end

        state:setAvailableCustomDimensions02(customDimensions)
    end)
end

function ga:configureAvailableCustomDimensions03(customDimensions)
    threading:performTaskOnGAThread(function()
        if isSdkReady({needsInitialized=true, shouldWarn=false}) then
            logger:w("Available custom dimensions must be set before SDK is initialized")
            return
        end

        state:setAvailableCustomDimensions03(customDimensions)
    end)
end

function ga:configureAvailableResourceCurrencies(resourceCurrencies)
    threading:performTaskOnGAThread(function()
        if isSdkReady({needsInitialized=true, shouldWarn=false}) then
            logger:w("Available resource currencies must be set before SDK is initialized")
            return
        end

        events:setAvailableResourceCurrencies(resourceCurrencies)
    end)
end

function ga:configureAvailableResourceItemTypes(resourceItemTypes)
    threading:performTaskOnGAThread(function()
        if isSdkReady({needsInitialized=true, shouldWarn=false}) then
            logger:w("Available resource item types must be set before SDK is initialized")
            return
        end

        events:setAvailableResourceItemTypes(resourceItemTypes)
    end)
end

function ga:configureBuild(build)
    threading:performTaskOnGAThread(function()
        if isSdkReady({needsInitialized=true, shouldWarn=false}) then
            logger:w("Build version must be set before SDK is initialized.")
            return
        end

        events:setBuild(build)
    end)
end

function ga:initialize(options)
    threading:performTaskOnGAThread(function()
        if isSdkReady({needsInitialized=true, shouldWarn=false}) then
            logger:w("SDK already initialized. Can only be called once.")
            return
        end

        local gameKey = options["gameKey"]
        local secretKey = options["secretKey"]

        if not validation:validateKeys(gameKey, secretKey) then
            logger:w("SDK failed initialize. Game key or secret key is invalid. Can only contain characters A-z 0-9, gameKey is 32 length, secretKey is 40 length. Failed keys - gameKey: " .. gameKey .. ", secretKey: " .. secretKey)
            return
        end

        events.GameKey = gameKey
        events.SecretKey = secretKey

        state.Initialized = true
        events:processEventQueue()

    end)
end

function ga:startNewSession(player, teleportData)
    threading:performTaskOnGAThread(function()
        if not state:isEventSubmissionEnabled() then
            return
        end
        if not state.Initialized then
            logger:w("Cannot start new session. SDK is not initialized yet.")
            return
        end

        state:startNewSession(player, teleportData)
    end)
end

function ga:endSession(playerId)
    threading:performTaskOnGAThread(function()
        if not state:isEventSubmissionEnabled() then
            return
        end
        state:endSession(playerId)
    end)
end

function ga:addBusinessEvent(playerId, options)
    threading:performTaskOnGAThread(function()
        if not state:isEventSubmissionEnabled() then
            return
        end
        if not isSdkReady({playerId=playerId, needsInitialized=true, shouldWarn=true, message="Could not add business event"}) then
            return
        end

        -- Send to events
        local amount = options["amount"] or 0
        local itemType = options["itemType"] or ""
        local itemId = options["itemId"] or ""
        local cartType = options["cartType"] or ""
        local USDSpent = math.floor((amount * 0.7) * 0.35)

        events:addBusinessEvent(playerId, "USD", USDSpent, itemType, itemId, cartType)
    end)
end

function ga:addResourceEvent(playerId, options)
    threading:performTaskOnGAThread(function()
        if not state:isEventSubmissionEnabled() then
            return
        end
        if not isSdkReady({playerId=playerId, needsInitialized=true, shouldWarn=true, message="Could not add resource event"}) then
            return
        end

        -- Send to events
        local flowType = options["flowType"] or 0
        local currency = options["currency"] or ""
        local amount = options["amount"] or 0
        local itemType = options["itemType"] or ""
        local itemId = options["itemId"] or ""

        events:addResourceEvent(playerId, flowType, currency, amount, itemType, itemId)
    end)
end

function ga:addProgressionEvent(playerId, options)
    threading:performTaskOnGAThread(function()
        if not state:isEventSubmissionEnabled() then
            return
        end
        if not isSdkReady({playerId=playerId, needsInitialized=true, shouldWarn=true, message="Could not add progression event"}) then
            return
        end

        -- Send to events
        local progressionStatus = options["progressionStatus"] or 0
        local progression01 = options["progression01"] or ""
        local progression02 = options["progression02"] or nil
        local progression03 = options["progression03"] or nil
        local score = options["score"] or nil

        events:addProgressionEvent(playerId, progressionStatus, progression01, progression02, progression03, score)
    end)
end

function ga:addDesignEvent(playerId, options)
    threading:performTaskOnGAThread(function()
        if not state:isEventSubmissionEnabled() then
            return
        end
        if not isSdkReady({playerId=playerId, needsInitialized=true, shouldWarn=true, message="Could not add design event"}) then
            return
        end

        -- Send to events
        local eventId = options["eventId"] or ""
        local value = options["value"] or nil

        events:addDesignEvent(playerId, eventId, value)
    end)
end

function ga:addErrorEvent(playerId, options)
    threading:performTaskOnGAThread(function()
        if not state:isEventSubmissionEnabled() then
            return
        end
        if not isSdkReady({playerId=playerId, needsInitialized=true, shouldWarn=true, message="Could not add error event"}) then
            return
        end

        -- Send to events
        local severity = options["severity"] or 0
        local message = options["message"] or ""

        events:addErrorEvent(playerId, severity, message)
    end)
end

function ga:setEnabledDebugLog(flag)
    threading:performTaskOnGAThread(function()
        if RunService:IsStudio() then
            if flag then
                logger:setDebugLog(flag)
                logger:i("Debug logging enabled")
            else
                logger:i("Debug logging disabled")
                logger:setDebugLog(flag)
            end
        else
            logger:i("setEnabledDebugLog can only be used in studio")
        end
    end)
end

function ga:setEnabledInfoLog(flag)
    threading:performTaskOnGAThread(function()
        if flag then
            logger:setInfoLog(flag)
            logger:i("Info logging enabled")
        else
            logger:i("Info logging disabled")
            logger:setInfoLog(flag)
        end
    end)
end

function ga:setEnabledVerboseLog(flag)
    threading:performTaskOnGAThread(function()
        if flag then
            logger:setVerboseLog(flag)
            logger:ii("Verbose logging enabled")
        else
            logger:ii("Verbose logging disabled")
            logger:setVerboseLog(flag)
        end
    end)
end

function ga:setEnabledEventSubmission(flag)
    threading:performTaskOnGAThread(function()
        if flag then
            state:setEventSubmission(flag)
            logger:i("Event submission enabled")
        else
            logger:i("Event submission disabled")
            state:setEventSubmission(flag)
        end
    end)
end

function ga:setCustomDimension01(playerId, dimension)
    threading:performTaskOnGAThread(function()
        if not validation:validateDimension(state._availableCustomDimensions01, dimension) then
            logger:w("Could not set custom01 dimension value to '" .. dimension .. "'. Value not found in available custom01 dimension values")
            return
        end
        if not isSdkReady({playerId=playerId, needsInitialized=true, shouldWarn=true, message="Could not set custom01 dimension"}) then
            return
        end

        state:setCustomDimension01(playerId, dimension)
    end)
end

function ga:setCustomDimension02(playerId, dimension)
    threading:performTaskOnGAThread(function()
        if not validation:validateDimension(state._availableCustomDimensions02, dimension) then
            logger:w("Could not set custom02 dimension value to '" .. dimension .. "'. Value not found in available custom02 dimension values")
            return
        end
        if not isSdkReady({playerId=playerId, needsInitialized=true, shouldWarn=true, message="Could not set custom02 dimension"}) then
            return
        end

        state:setCustomDimension02(playerId, dimension)
    end)
end

function ga:setCustomDimension03(playerId, dimension)
    threading:performTaskOnGAThread(function()
        if not validation:validateDimension(state._availableCustomDimensions03, dimension) then
            logger:w("Could not set custom03 dimension value to '" .. dimension .. "'. Value not found in available custom03 dimension values")
            return
        end
        if not isSdkReady({playerId=playerId, needsInitialized=true, shouldWarn=true, message="Could not set custom03 dimension"}) then
            return
        end
        state:setCustomDimension03(playerId, dimension)
    end)
end

function ga:setEnabledReportErrors(flag)
    threading:performTaskOnGAThread(function()
        state.ReportErrors = flag
    end)
end

function ga:setEnabledAutomaticSendBusinessEvents(flag)
    threading:performTaskOnGAThread(function()
        state.AutomaticSendBusinessEvents = flag
    end)
end

function ga:addGameAnalyticsTeleportData(playerIds, teleportData)
    local gameAnalyticsTeleportData = {}
    for index = 1, #playerIds do
        local playerId = playerIds[index]
        local PlayerData = store.PlayerCache[playerId]
        PlayerData.PlayerTeleporting = true
        local data = {
            ["SessionID"] = PlayerData.SessionID,
            ["Sessions"] = PlayerData.Sessions,
            ["SessionStart"] = PlayerData.SessionStart
        }
        gameAnalyticsTeleportData[tostring(playerId)] = data
    end

    teleportData["gameanalyticsData"] = gameAnalyticsTeleportData

    return teleportData
end

function ga:getCommandCenterValueAsString(playerId, options)
    local key = options["key"] or ""
    local defaultValue = options["defaultValue"] or nil
    return state:getConfigurationStringValue(playerId, key, defaultValue)
end

function ga:isCommandCenterReady(playerId)
    return state:isCommandCenterReady(playerId)
end

function ga:getConfigurationsContentAsString(playerId)
    return state:getConfigurationsContentAsString(playerId)
end

function ga:PlayerJoined(Player, teleportData)
    if store.PlayerCache[Player.UserId] then
        return
    end

    --Variables
    local PlayerData = store:GetPlayerData(Player)

    local PlayerPlatform = "unknown"
    local isSuccessful, platform = Postie.InvokeClient("getPlatform", Player, 5)
    if isSuccessful then
        PlayerPlatform = platform
    end

    --Fill Data
    for key, value in pairs(store.BasePlayerData) do
        PlayerData[key] = PlayerData[key] or value
    end

    store.PlayerCache[Player.UserId] = PlayerData

    PlayerData.Platform = (PlayerPlatform == "Console" and "uwp_console") or (PlayerPlatform == "Mobile" and "uwp_mobile") or (PlayerPlatform == "Desktop" and "uwp_desktop") or ("unknown")
    PlayerData.OS = PlayerData.Platform .. " 0.0.0"

    ga:startNewSession(Player, teleportData)


    --Autosave
    spawn(function()

        --Loop
        while true do

            --Delay
            wait(store.AutoSaveData)

            --Validate
            if (not Player) or (Player.Parent ~= Players) then return end

            --Save
            store:SavePlayerData(Player)
        end
    end)
end

function ga:PlayerRemoved(Player)
    --Save
    store:SavePlayerData(Player)

    local PlayerData = store.PlayerCache[Player.UserId]
    if not PlayerData.PlayerTeleporting then
        ga:endSession(Player.UserId)
    end
end

function ga:ProcessReceiptCallback(Info)

    --Variables
    local ProductInfo = ProductCache[Info.ProductId]

    --Cache
    if not ProductInfo then
        --Get
        ProductInfo = MKT:GetProductInfo(Info.ProductId, Enum.InfoType.Product)
        ProductCache[Info.ProductId] = ProductInfo
    end

    ga:addBusinessEvent(Info.PlayerId, {
        amount = Info.CurrencySpent,
        itemType = "DeveloperProduct",
        itemId = ProductInfo.Name
    })
end

return ga
]]></ProtectedString>
                <BinaryString name="Tags"></BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="RBX34831ce54bf7450a8e97b4ff9458caa6">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">Settings</string>
                    <string name="ScriptGuid"></string>
                    <ProtectedString name="Source"><![CDATA[local settings = {
    EnableInfoLog = true,
    EnableVerboseLog = false,
    AutomaticSendBusinessEvents = true,
    ReportErrors = true,
    Build = "0.1",
    AvailableCustomDimensions01 = {},
    AvailableCustomDimensions02 = {},
    AvailableCustomDimensions03 = {},
    AvailableResourceCurrencies = {},
    AvailableResourceItemTypes = {},
    GameKey = "",
    SecretKey = ""
}

return settings
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
            </Item>
            <Item class="ModuleScript" referent="RBXd615e5db16034cae976316f3d4fea9e0">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">HttpApi</string>
                    <string name="ScriptGuid"></string>
                    <ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local validation = require(script.Parent.Validation)
local version = require(script.Parent.Version)

local http_api = {
    protocol = "https",
    hostName = "api.gameanalytics.com",
    version = "v2",
    initializeUrlPath = "init",
    eventsUrlPath = "events",
    EGAHTTPApiResponse = {
        NoResponse=0,
        BadResponse=1,
        RequestTimeout=2,
        JsonEncodeFailed=3,
        JsonDecodeFailed=4,
        InternalServerError=5,
        BadRequest=6,
        Unauthorized=7,
        UnknownResponseCode=8,
        Ok=9
    }
}

local HTTP = game:GetService("HttpService")
local logger = require(script.Parent.Logger)
local baseUrl = (RunService:IsStudio() and "http" or http_api.protocol) .. "://" .. (RunService:IsStudio() and "sandbox-" or "") .. http_api.hostName .. "/" .. http_api.version
local encodingReady = false

local Encoding = {}

local function getInitAnnotations(playerData, playerId)
    local initAnnotations = {
        ["user_id"] = tostring(playerId),
        ["sdk_version"] = "roblox " .. version.SdkVersion,
        ["os_version"] = playerData.OS,
        ["platform"] = playerData.Platform
    }

    return initAnnotations
end

local function encode(payload, secretKey)
    if not encodingReady then
        Encoding.lockbox = require(script.Encoding.lockbox)
        Encoding.lockbox.bit = require(script.Encoding.bit).bit
        Encoding.array = require(Encoding.lockbox.util.array)
        Encoding.stream = require(Encoding.lockbox.util.stream)
        Encoding.base64 = require(Encoding.lockbox.util.base64)
        Encoding.hmac = require(Encoding.lockbox.mac.hmac)
        Encoding.sha256 = require(Encoding.lockbox.digest.sha2_256)
        encodingReady = true
    end

    --Validate
    if not secretKey then logger:w("Error encoding, invalid SecretKey") return end

    --Encode
    local hmacBuilder = Encoding.hmac()
        .setBlockSize(64)
        .setDigest(Encoding.sha256)
        .setKey(Encoding.array.fromString(RunService:IsStudio() and "16813a12f718bc5c620f56944e1abc3ea13ccbac" or secretKey))
        .init()
        .update(Encoding.stream.fromString(payload))
        .finish()

    return Encoding.base64.fromArray(hmacBuilder.asBytes())
end

local function processRequestResponse(response, requestId)
    local statusCode = response.StatusCode
    local body = response.Body

    if not body or #body == 0 then
        logger:d(requestId .. " request. failed. Might be no connection. Status code: " .. tostring(statusCode))
        return http_api.EGAHTTPApiResponse.NoResponse
    end

    if statusCode == 200 then
        return http_api.EGAHTTPApiResponse.Ok
    elseif statusCode == 0 or statusCode == 401 then
        logger:d(requestId .. " request. 401 - Unauthorized.")
        return http_api.EGAHTTPApiResponse.Unauthorized
    elseif statusCode == 400 then
        logger:d(requestId .. " request. 400 - Bad Request.")
        return http_api.EGAHTTPApiResponse.BadRequest
    elseif statusCode == 500 then
        logger:d(requestId .. " request. 500 - Internal Server Error.")
        return http_api.EGAHTTPApiResponse.InternalServerError
    else
        return http_api.EGAHTTPApiResponse.UnknownResponseCode
    end
end

function http_api:initRequest(gameKey, secretKey, playerData, playerId)
    local url = "https://rubick.gameanalytics.com/v2/command_center?game_key=" .. gameKey .. "&interval_seconds=1000000"
    if RunService:IsStudio() then
        url = baseUrl .. "/5c6bcb5402204249437fb5a7a80a4959/" .. self.initializeUrlPath
    end

    logger:d("Sending 'init' URL: " .. url)

    local payload = HTTP:JSONEncode(getInitAnnotations(playerData, playerId))
    local authorization = encode(payload, secretKey)

    local res
    local success, err = pcall(function()
        res = HTTP:RequestAsync({
            Url = url,
            Method = "POST",
            Headers = {
                ["Authorization"] = authorization
            },
            Body = payload
        })
    end)

    if not success then
        logger:d("Failed Init Call. error: " .. err)
        return {
            statusCode = http_api.EGAHTTPApiResponse.UnknownResponseCode,
            body = nil
        }
    end
    logger:d("init request content: " .. res.Body)

    local requestResponseEnum = processRequestResponse(res, "Init")

    -- if not 200 result
    if requestResponseEnum ~= http_api.EGAHTTPApiResponse.Ok and requestResponseEnum ~= http_api.EGAHTTPApiResponse.BadRequest then
        logger:d("Failed Init Call. URL: " .. url .. ", JSONString: " .. payload .. ", Authorization: " .. authorization)
        return {
            statusCode = requestResponseEnum,
            body = nil
        }
    end

    --Response
    local responseBody
    success, _ = ypcall(function()
        responseBody = HTTP:JSONDecode(res.Body)
    end)

    if not success then
        logger:d("Failed Init Call. Json decoding failed: " .. err)
        return {
            statusCode = http_api.EGAHTTPApiResponse.JsonDecodeFailed,
            body = nil
        }
    end

    -- print reason if bad request
    if requestResponseEnum == http_api.EGAHTTPApiResponse.BadRequest then
        logger:d("Failed Init Call. Bad request. Response: " .. res.Body)
        return {
            statusCode = requestResponseEnum,
            body = nil
        }
    end

    -- validate Init call values
    local validatedInitValues = validation:validateAndCleanInitRequestResponse(responseBody)

    if not validatedInitValues then
        return {
            statusCode = http_api.EGAHTTPApiResponse.BadResponse,
            body = nil
        }
    end

    -- all ok
    return {
        statusCode = http_api.EGAHTTPApiResponse.Ok,
        body = responseBody
    }
end

function http_api:sendEventsInArray(gameKey, secretKey, eventArray)
    if not eventArray or #eventArray == 0 then
        logger:d("sendEventsInArray called with missing eventArray")
        return
    end

    -- Generate URL
    local url = baseUrl .. "/" .. gameKey .. "/" .. self.eventsUrlPath
    if RunService:IsStudio() then
        url = baseUrl .. "/5c6bcb5402204249437fb5a7a80a4959/" .. self.eventsUrlPath
    end

    logger:d("Sending 'events' URL: " .. url)

    -- make JSON string from data
    local payload = HTTP:JSONEncode(eventArray)
    local authorization = encode(payload, secretKey)

    local res
    local success, err = pcall(function()
        res = HTTP:RequestAsync({
            Url = url,
            Method = "POST",
            Headers = {
                ["Authorization"] = authorization
            },
            Body = payload
        })
    end)

    if not success then
        logger:d("Failed Events Call. error: " .. err)
        return {
            statusCode = http_api.EGAHTTPApiResponse.UnknownResponseCode,
            body = nil
        }
    end


    logger:d("body: " .. res.Body)
    local requestResponseEnum = processRequestResponse(res, "Events")

    -- if not 200 result
    if requestResponseEnum ~= http_api.EGAHTTPApiResponse.Ok and requestResponseEnum ~= http_api.EGAHTTPApiResponse.BadRequest then
        logger:d("Failed Events Call. URL: " .. url .. ", JSONString: " .. payload .. ", Authorization: " .. authorization)
        return {
            statusCode = requestResponseEnum,
            body = nil
        }
    end

    local responseBody
    ypcall(function()
        responseBody = HTTP:JSONDecode(res.Body)
    end)

    if not responseBody then
        logger:d("Failed Events Call. Json decoding failed")
        return {
            statusCode = http_api.EGAHTTPApiResponse.JsonDecodeFailed,
            body = nil
        }
    end

    -- print reason if bad request
    if requestResponseEnum == http_api.EGAHTTPApiResponse.BadRequest then
        logger:d("Failed Events Call. Bad request. Response: " .. res.Body)
        return {
            statusCode = requestResponseEnum,
            body = nil
        }
    end

    -- all ok
    return {
        statusCode = http_api.EGAHTTPApiResponse.Ok,
        body = responseBody
    }
end

return http_api
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
                <Item class="Folder" referent="RBX419df056fc0b48818fe911db5cdea52b">
                    <Properties>
                        <string name="Name">Encoding</string>
                        <BinaryString name="Tags"></BinaryString>
                    </Properties>
                    <Item class="ModuleScript" referent="RBX9e3a0d8e67d748a6a311e68092173f46">
                        <Properties>
                            <Content name="LinkedSource"><null></null></Content>
                            <string name="Name">lockbox</string>
                            <string name="ScriptGuid"></string>
                            <ProtectedString name="Source"><![CDATA[local lockbox = {ALLOW_INSECURE = false}

for _,v in pairs(script:GetChildren()) do
    lockbox[v.Name] = v
end

return lockbox
]]></ProtectedString>
                            <BinaryString name="Tags"></BinaryString>
                        </Properties>
                        <Item class="Folder" referent="RBX2dda4596184d45a4a91955d7738a62ab">
                            <Properties>
                                <string name="Name">util</string>
                                <BinaryString name="Tags"></BinaryString>
                            </Properties>
                            <Item class="ModuleScript" referent="RBX2e1e8e5695804d9eaf55991d9c18e2b8">
                                <Properties>
                                    <Content name="LinkedSource"><null></null></Content>
                                    <string name="Name">stream</string>
                                    <string name="ScriptGuid"></string>
                                    <ProtectedString name="Source"><![CDATA[local lockbox = script.Parent.Parent

local Queue = require(lockbox.util.queue);
local String = string;

local Stream = {};


Stream.fromString = function(string)
    local i=0;
    return function()
        i=i+1;
        if(i <= String.len(string)) then
            return String.byte(string,i);
        else
            return nil;
        end
    end
end


Stream.toString = function(stream)
    local array = {};
    local i=1;

    local byte = stream();
    while byte ~= nil do
        array[i] = String.char(byte);
        i = i+1;
        byte = stream();
    end

    return table.concat(array,"");
end


Stream.fromArray = function(array)
    local queue = Queue();
    local i=1;

    local byte = array[i];
    while byte ~= nil do
        queue.push(byte);
        i=i+1;
        byte = array[i];
    end

    return queue.pop;
end


Stream.toArray = function(stream)
    local array = {};
    local i=1;

    local byte = stream();
    while byte ~= nil do
        array[i] = byte;
        i = i+1;
        byte = stream();
    end

    return array;
end


local fromHexTable = {};
for i=0,255 do
    fromHexTable[String.format("%02X",i)]=i;
    fromHexTable[String.format("%02x",i)]=i;
end

Stream.fromHex = function(hex)
    local queue = Queue();

    for i=1,String.len(hex)/2 do
        local h = String.sub(hex,i*2-1,i*2);
        queue.push(fromHexTable[h]);
    end

    return queue.pop;
end



local toHexTable = {};
for i=0,255 do
    toHexTable[i]=String.format("%02X",i);
end

Stream.toHex = function(stream)
    local hex = {};
    local i = 1;

    local byte = stream();
    while byte ~= nil do
        hex[i] = toHexTable[byte];
        i=i+1;
        byte = stream();
    end

    return table.concat(hex,"");
end

return Stream;
]]></ProtectedString>
                                    <BinaryString name="Tags"></BinaryString>
                                </Properties>
                            </Item>
                            <Item class="ModuleScript" referent="RBX6fd16a0a5a5140d2adf1c03caeec1b69">
                                <Properties>
                                    <Content name="LinkedSource"><null></null></Content>
                                    <string name="Name">queue</string>
                                    <string name="ScriptGuid"></string>
                                    <ProtectedString name="Source"><![CDATA[local Queue = function()
    local queue = {};
    local tail = 0;
    local head = 0;

    local public = {};

    public.push = function(obj)
        queue[head] = obj;
        head = head + 1;
        return;
    end

    public.pop = function()
        if tail < head
        then
            local obj = queue[tail];
            queue[tail] = nil;
            tail = tail + 1;
            return obj;
        else
            return nil;
        end
    end

    public.size = function()
        return head - tail;
    end

    public.getHead = function()
        return head;
    end

    public.getTail = function()
        return tail;
    end

    public.reset = function()
        queue = {};
        head = 0;
        tail = 0;
    end

    return public;
end

return Queue;
]]></ProtectedString>
                                    <BinaryString name="Tags"></BinaryString>
                                </Properties>
                            </Item>
                            <Item class="ModuleScript" referent="RBX87e03de0ae5c4c32a1cd8874ef1a02bd">
                                <Properties>
                                    <Content name="LinkedSource"><null></null></Content>
                                    <string name="Name">array</string>
                                    <string name="ScriptGuid"></string>
                                    <ProtectedString name="Source"><![CDATA[local lockbox = script.Parent.Parent

local String = string;
local Queue = require(lockbox.util.queue);
local Bit = require(lockbox.util.bit);

local XOR = Bit.bxor;

local Array = {};

Array.size = function(array)
    return #array;
end

Array.fromString = function(string)
    local bytes = {};

    local i=1;
    local byte = String.byte(string,i);
    while byte ~= nil do
        bytes[i] = byte;
        i = i + 1;
        byte = String.byte(string,i);
    end

    return bytes;

end

Array.toString = function(bytes)
    local chars = {};
    local i=1;

    local byte = bytes[i];
    while byte ~= nil do
        chars[i] = String.char(byte);
        i = i+1;
        byte = bytes[i];
    end

    return table.concat(chars,"");
end

Array.fromStream = function(stream)
    local array = {};
    local i=1;

    local byte = stream();
    while byte ~= nil do
        array[i] = byte;
        i = i+1;
        byte = stream();
    end

    return array;
end

Array.readFromQueue = function(queue,size)
    local array = {};

    for i=1,size do
        array[i] = queue.pop();
    end

    return array;
end

Array.writeToQueue = function(queue,array)
    local size = Array.size(array);

    for i=1,size do
        queue.push(array[i]);
    end
end

Array.toStream = function(array)
    local queue = Queue();
    local i=1;

    local byte = array[i];
    while byte ~= nil do
        queue.push(byte);
        i=i+1;
        byte = array[i];
    end

    return queue.pop;
end


local fromHexTable = {};
for i=0,255 do
    fromHexTable[String.format("%02X",i)]=i;
    fromHexTable[String.format("%02x",i)]=i;
end

Array.fromHex = function(hex)
    local array = {};

    for i=1,String.len(hex)/2 do
        local h = String.sub(hex,i*2-1,i*2);
        array[i] = fromHexTable[h];
    end

    return array;
end


local toHexTable = {};
for i=0,255 do
    toHexTable[i]=String.format("%02X",i);
end

Array.toHex = function(array)
    local hex = {};
    local i = 1;

    local byte = array[i];
    while byte ~= nil do
        hex[i] = toHexTable[byte];
        i=i+1;
        byte = array[i];
    end

    return table.concat(hex,"");

end

Array.concat = function(a,b)
    local concat = {};
    local out=1;

    local i=1;
    local byte = a[i];
    while byte ~= nil do
        concat[out] = byte;
        i = i + 1;
        out = out + 1;
        byte = a[i];
    end

    i=1;
    byte = b[i];
    while byte ~= nil do
        concat[out] = byte;
        i = i + 1;
        out = out + 1;
        byte = b[i];
    end

    return concat;
end

Array.truncate = function(a,newSize)
    local x = {};

    for i=1,newSize do
        x[i]=a[i];
    end

    return x;
end

Array.XOR = function(a,b)
    local x = {};

    for k,v in pairs(a) do
        x[k] = XOR(v,b[k]);
    end

    return x;
end

Array.substitute = function(input,sbox)
    local out = {};

    for k,v in pairs(input) do
        out[k] = sbox[v];
    end

    return out;
end

Array.permute = function(input,pbox)
    local out = {};

    for k,v in pairs(pbox) do
        out[k] = input[v];
    end

    return out;
end

Array.copy = function(input)
    local out = {};

    for k,v in pairs(input) do
        out[k] = v;
    end
    return out;
end

Array.slice = function(input,start,stop)
    local out = {};

    for i=start,stop do
        out[i-start+1] = input[i];
    end
    return out;
end

return Array;
]]></ProtectedString>
                                    <BinaryString name="Tags"></BinaryString>
                                </Properties>
                            </Item>
                            <Item class="ModuleScript" referent="RBXab0edb14e1a7431d84930f2cd95e5919">
                                <Properties>
                                    <Content name="LinkedSource"><null></null></Content>
                                    <string name="Name">base64</string>
                                    <string name="ScriptGuid"></string>
                                    <ProtectedString name="Source"><![CDATA[local lockbox = script.Parent.Parent

local String = string;
local Bit = require(lockbox.util.bit);

local Array = require(lockbox.util.array);
local Stream = require(lockbox.util.stream);

local AND = Bit.band;
local OR  = Bit.bor;
local NOT = Bit.bnot;
--local XOR = Bit.bxor;
--local LROT = Bit.lrotate;
--local RROT = Bit.rrotate;
local LSHIFT = Bit.lshift;
local RSHIFT = Bit.rshift;


local SYMBOLS = {
[0]="A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P",
    "Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f",
    "g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v",
    "w","x","y","z","0","1","2","3","4","5","6","7","8","9","+","/"};

local LOOKUP = {};

for k,v in pairs(SYMBOLS) do
    LOOKUP[k]=v;
    LOOKUP[v]=k;
end


local Base64 = {};

Base64.fromStream = function(stream)
    local bits = 0x00;
    local bitCount = 0;
    local base64 = {};

    local byte = stream();
    while byte ~= nil do
        bits = OR(LSHIFT(bits,8),byte);
        bitCount = bitCount + 8;
        while bitCount >= 6 do
            bitCount = bitCount - 6;
            local temp = RSHIFT(bits,bitCount);
            table.insert(base64,LOOKUP[temp]);
            bits = AND(bits,NOT(LSHIFT(0xFFFFFFFF,bitCount)));
        end
        byte = stream();
    end

    if (bitCount == 4) then
        bits = LSHIFT(bits,2);
        table.insert(base64,LOOKUP[bits]);
        table.insert(base64,"=");
    elseif (bitCount == 2) then
        bits = LSHIFT(bits,4);
        table.insert(base64,LOOKUP[bits]);
        table.insert(base64,"==");
    end

    return table.concat(base64,"");
end

Base64.fromArray = function(array)
    local bits = 0x00;
    local bitCount = 0;
    local base64 = {};

    local ind = 1;

    local byte = array[ind]; ind = ind + 1;
    while byte ~= nil do
        bits = OR(LSHIFT(bits,8),byte);
        bitCount = bitCount + 8;
        while bitCount >= 6 do
            bitCount = bitCount - 6;
            local temp = RSHIFT(bits,bitCount);
            table.insert(base64,LOOKUP[temp]);
            bits = AND(bits,NOT(LSHIFT(0xFFFFFFFF,bitCount)));
        end
        byte = array[ind]; ind = ind + 1;
    end

    if (bitCount == 4) then
        bits = LSHIFT(bits,2);
        table.insert(base64,LOOKUP[bits]);
        table.insert(base64,"=");
    elseif (bitCount == 2) then
        bits = LSHIFT(bits,4);
        table.insert(base64,LOOKUP[bits]);
        table.insert(base64,"==");
    end

    return table.concat(base64,"");
end

Base64.fromString = function(string)
    return Base64.fromArray(Array.fromString(string));
end



Base64.toStream = function(base64)
    return Stream.fromArray(Base64.toArray(base64));
end

Base64.toArray = function(base64)
    local bits = 0x00;
    local bitCount = 0;

    local bytes = {};

    for c in String.gmatch(base64,".") do
        if (c == "=") then
            bits = RSHIFT(bits,2); bitCount = bitCount - 2;
        else
            bits = LSHIFT(bits,6); bitCount = bitCount + 6;
            bits = OR(bits,LOOKUP[c]);
        end

        while(bitCount >= 8) do
            bitCount = bitCount - 8;
            local temp = RSHIFT(bits,bitCount);
            table.insert(bytes,temp);
            bits = AND(bits,NOT(LSHIFT(0xFFFFFFFF,bitCount)));
        end
    end

    return bytes;
end

Base64.toString = function(base64)
    local bits = 0x00;
    local bitCount = 0;

    local chars = {};

    for c in String.gmatch(base64,".") do
        if (c == "=") then
            bits = RSHIFT(bits,2); bitCount = bitCount - 2;
        else
            bits = LSHIFT(bits,6); bitCount = bitCount + 6;
            bits = OR(bits,LOOKUP[c]);
        end

        while(bitCount >= 8) do
            bitCount = bitCount - 8;
            local temp = RSHIFT(bits,bitCount);
            table.insert(chars,String.char(temp));
            bits = AND(bits,NOT(LSHIFT(0xFFFFFFFF,bitCount)));
        end
    end

    return table.concat(chars,"");
end

return Base64;
]]></ProtectedString>
                                    <BinaryString name="Tags"></BinaryString>
                                </Properties>
                            </Item>
                            <Item class="ModuleScript" referent="RBXe0335e45fc804c34a6c9e8af63aaae2b">
                                <Properties>
                                    <Content name="LinkedSource"><null></null></Content>
                                    <string name="Name">bit</string>
                                    <string name="ScriptGuid"></string>
                                    <ProtectedString name="Source"><![CDATA[local lockbox = script.Parent.Parent

e = require(lockbox).bit

if not e then
    error("no bitwise support found", 2)
end

-- Workaround to support Lua 5.2 bit32 API with the LuaJIT bit one
if e.rol and not e.lrotate then
    e.lrotate = e.rol
end
if e.ror and not e.rrotate then
    e.rrotate = e.ror
end

return e
]]></ProtectedString>
                                    <BinaryString name="Tags"></BinaryString>
                                </Properties>
                            </Item>
                        </Item>
                        <Item class="Folder" referent="RBXdc2f1f7d26b248fbbed00705303d8be4">
                            <Properties>
                                <string name="Name">mac</string>
                                <BinaryString name="Tags"></BinaryString>
                            </Properties>
                            <Item class="ModuleScript" referent="RBXbe6ae6e782124123884e3623c338888e">
                                <Properties>
                                    <Content name="LinkedSource"><null></null></Content>
                                    <string name="Name">hmac</string>
                                    <string name="ScriptGuid"></string>
                                    <ProtectedString name="Source"><![CDATA[local lockbox = script.Parent.Parent

local Bit = require(lockbox.util.bit);
--local String = string;
local Stream = require(lockbox.util.stream);
local Array = require(lockbox.util.array);

local XOR = Bit.bxor;

local HMAC = function()

    local public = {};
    local blockSize = 64;
    local Digest = nil;
    local outerPadding = {};
    local innerPadding = {}
    local digest;

    public.setBlockSize = function(bytes)
        blockSize = bytes;
        return public;
    end

    public.setDigest = function(digestModule)
        Digest = digestModule;
        digest = Digest();
        return public;
    end

    public.setKey = function(key)
        local keyStream;

        if(Array.size(key) > blockSize) then
            keyStream = Stream.fromArray(Digest()
                        .update(Stream.fromArray(key))
                        .finish()
                        .asBytes());
        else
            keyStream = Stream.fromArray(key);
        end

        outerPadding = {};
        innerPadding = {};

        for i=1,blockSize do
            local byte = keyStream();
            if byte == nil then byte = 0x00; end
            outerPadding[i] = XOR(0x5C,byte);
            innerPadding[i] = XOR(0x36,byte);
        end

        return public;
    end

    public.init = function()
        digest    .init()
                .update(Stream.fromArray(innerPadding));
        return public;
    end

    public.update = function(messageStream)
        digest.update(messageStream);
        return public;
    end

    public.finish = function()
        local inner = digest.finish().asBytes();
        digest    .init()
                .update(Stream.fromArray(outerPadding))
                .update(Stream.fromArray(inner))
                .finish();

        return public;
    end

    public.asBytes = function()
        return digest.asBytes();
    end

    public.asHex = function()
        return digest.asHex();
    end

    return public;

end

return HMAC;
]]></ProtectedString>
                                    <BinaryString name="Tags"></BinaryString>
                                </Properties>
                            </Item>
                        </Item>
                        <Item class="Folder" referent="RBX04e894e82e894852a78bbe267f159152">
                            <Properties>
                                <string name="Name">digest</string>
                                <BinaryString name="Tags"></BinaryString>
                            </Properties>
                            <Item class="ModuleScript" referent="RBX7fc7f21985054de0bab9afe1363b36b3">
                                <Properties>
                                    <Content name="LinkedSource"><null></null></Content>
                                    <string name="Name">sha2_256</string>
                                    <string name="ScriptGuid"></string>
                                    <ProtectedString name="Source"><![CDATA[local lockbox = script.Parent.Parent

local Bit = require(lockbox.util.bit);
local String = string;
local Math = math;
local Queue = require(lockbox.util.queue);
local heartbeat = game:GetService("RunService").Heartbeat

local CONSTANTS = {
   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2  };

local AND = Bit.band;
local OR  = Bit.bor;
local NOT = Bit.bnot;
local XOR = Bit.bxor;
--local LROT = Bit.lrotate;
local RROT = Bit.rrotate;
local LSHIFT = Bit.lshift;
local RSHIFT = Bit.rshift;

--SHA2 is big-endian
local bytes2word = function(b0,b1,b2,b3)
    local i = b0; i = LSHIFT(i,8);
    i = OR(i,b1); i = LSHIFT(i,8);
    i = OR(i,b2); i = LSHIFT(i,8);
    i = OR(i,b3);
    return i;
end

local word2bytes = function(word)
    local b0,b1,b2,b3;
    b3 = AND(word,0xFF); word = RSHIFT(word,8);
    b2 = AND(word,0xFF); word = RSHIFT(word,8);
    b1 = AND(word,0xFF); word = RSHIFT(word,8);
    b0 = AND(word,0xFF);
    return b0,b1,b2,b3;
end

-- local bytes2dword = function(b0,b1,b2,b3,b4,b5,b6,b7)
--     local i = bytes2word(b0,b1,b2,b3);
--     local j = bytes2word(b4,b5,b6,b7);
--     return (i*0x100000000)+j;
-- end

local dword2bytes = function(i)
    local b4,b5,b6,b7 = word2bytes(i);
    local b0,b1,b2,b3 = word2bytes(Math.floor(i/0x100000000));
    return b0,b1,b2,b3,b4,b5,b6,b7;
end




local SHA2_256 = function()

    local queue = Queue();

    local h0 = 0x6a09e667;
    local h1 = 0xbb67ae85;
    local h2 = 0x3c6ef372;
    local h3 = 0xa54ff53a;
    local h4 = 0x510e527f;
    local h5 = 0x9b05688c;
    local h6 = 0x1f83d9ab;
    local h7 = 0x5be0cd19;

    local public = {};

    local processBlock = function()

        local a = h0;
        local b = h1;
        local c = h2;
        local d = h3;
        local e = h4;
        local f = h5;
        local g = h6;
        local h = h7;

        local w = {};
        for i=0,15 do
            w[i] = bytes2word(queue.pop(),queue.pop(),queue.pop(),queue.pop());
        end

        heartbeat:Wait()

        for i=16,63 do
            if i%20 == 0 then
                heartbeat:Wait()
            end
            local s0 = XOR(RROT(w[i-15],7), XOR(RROT(w[i-15],18), RSHIFT(w[i-15],3)));
            local s1 = XOR(RROT(w[i-2],17), XOR(RROT(w[i-2], 19), RSHIFT(w[i-2],10)));
            w[i] = AND(w[i-16] + s0 + w[i-7] + s1, 0xFFFFFFFF);
        end

        for i=0,63 do
            if i%12 == 0 then
                heartbeat:Wait()
            end
            local s1 = XOR(RROT(e,6), XOR(RROT(e,11),RROT(e,25)));
            local ch = XOR(AND(e,f), AND(NOT(e),g));
            local temp1 = h + s1 + ch + CONSTANTS[i+1] + w[i];
            local s0 = XOR(RROT(a,2), XOR(RROT(a,13), RROT(a,22)));
            local maj = XOR(AND(a,b), XOR(AND(a,c), AND(b,c)));
            local temp2 = s0 + maj;

            h = g;
            g = f;
            f = e;
            e = d + temp1;
            d = c;
            c = b;
            b = a;
            a = temp1 + temp2;
        end

        h0 = AND(h0 + a, 0xFFFFFFFF);
        h1 = AND(h1 + b, 0xFFFFFFFF);
        h2 = AND(h2 + c, 0xFFFFFFFF);
        h3 = AND(h3 + d, 0xFFFFFFFF);
        h4 = AND(h4 + e, 0xFFFFFFFF);
        h5 = AND(h5 + f, 0xFFFFFFFF);
        h6 = AND(h6 + g, 0xFFFFFFFF);
        h7 = AND(h7 + h, 0xFFFFFFFF);
        heartbeat:Wait()
    end

    public.init = function()
        queue.reset();

        h0 = 0x6a09e667;
        h1 = 0xbb67ae85;
        h2 = 0x3c6ef372;
        h3 = 0xa54ff53a;
        h4 = 0x510e527f;
        h5 = 0x9b05688c;
        h6 = 0x1f83d9ab;
        h7 = 0x5be0cd19;

        return public;
    end

    public.update = function(bytes)

        for b in bytes do
            queue.push(b);
            if queue.size() >= 64 then processBlock(); end
        end

        return public;
    end

    public.finish = function()
        local bits = queue.getHead() * 8;

        queue.push(0x80);
        while ((queue.size()+7) % 64) < 63 do
            queue.push(0x00);
        end

        local b0,b1,b2,b3,b4,b5,b6,b7 = dword2bytes(bits);

        queue.push(b0);
        queue.push(b1);
        queue.push(b2);
        queue.push(b3);
        queue.push(b4);
        queue.push(b5);
        queue.push(b6);
        queue.push(b7);

        while queue.size() > 0 do
            processBlock();
        end

        return public;
    end

    public.asBytes = function()
        local  b0, b1, b2, b3 = word2bytes(h0);
        local  b4, b5, b6, b7 = word2bytes(h1);
        local  b8, b9,b10,b11 = word2bytes(h2);
        local b12,b13,b14,b15 = word2bytes(h3);
        local b16,b17,b18,b19 = word2bytes(h4);
        local b20,b21,b22,b23 = word2bytes(h5);
        local b24,b25,b26,b27 = word2bytes(h6);
        local b28,b29,b30,b31 = word2bytes(h7);


        return {  b0, b1, b2, b3, b4, b5, b6, b7, b8, b9,b10,b11,b12,b13,b14,b15
                ,b16,b17,b18,b19,b20,b21,b22,b23,b24,b25,b26,b27,b28,b29,b30,b31};
    end

    public.asHex = function()
        local  b0, b1, b2, b3 = word2bytes(h0);
        local  b4, b5, b6, b7 = word2bytes(h1);
        local  b8, b9,b10,b11 = word2bytes(h2);
        local b12,b13,b14,b15 = word2bytes(h3);
        local b16,b17,b18,b19 = word2bytes(h4);
        local b20,b21,b22,b23 = word2bytes(h5);
        local b24,b25,b26,b27 = word2bytes(h6);
        local b28,b29,b30,b31 = word2bytes(h7);

        local fmt = "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"

        return String.format(fmt, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9,b10,b11,b12,b13,b14,b15
                ,b16,b17,b18,b19,b20,b21,b22,b23,b24,b25,b26,b27,b28,b29,b30,b31);
    end

    return public;

end

return SHA2_256;
]]></ProtectedString>
                                    <BinaryString name="Tags"></BinaryString>
                                </Properties>
                            </Item>
                        </Item>
                    </Item>
                    <Item class="ModuleScript" referent="RBX6d336f35031d46fd9427cab63c89cfba">
                        <Properties>
                            <Content name="LinkedSource"><null></null></Content>
                            <string name="Name">bit</string>
                            <string name="ScriptGuid"></string>
                            <ProtectedString name="Source"><![CDATA[local M = {_TYPE='module', _NAME='bit.numberlua', _VERSION='0.3.1.20120131'}

M.bits = 32

local floor = math.floor

local MOD = 2^32
local MODM = MOD-1

local function memoize(f)
  local mt = {}
  local t = setmetatable({}, mt)
  function mt:__index(k)
    local v = f(k); t[k] = v
    return v
  end
  return t
end

local function make_bitop_uncached(t, m)
  local function bitop(a, b)
    local res,p = 0,1
    while a ~= 0 and b ~= 0 do
      local am, bm = a%m, b%m
      res = res + t[am][bm]*p
      a = (a - am) / m
      b = (b - bm) / m
      p = p*m
    end
    res = res + (a+b)*p
    return res
  end
  return bitop
end

local function make_bitop(t)
  local op1 = make_bitop_uncached(t,2^1)
  local op2 = memoize(function(a)
    return memoize(function(b)
      return op1(a, b)
    end)
  end)
  return make_bitop_uncached(op2, 2^(t.n or 1))
end

-- ok?  probably not if running on a 32-bit int Lua number type platform
function M.tobit(x)
  return x % 2^32
end

M.cast = M.tobit

M.bxor = make_bitop {[0]={[0]=0,[1]=1},[1]={[0]=1,[1]=0}, n=4}
local bxor = M.bxor

function M.bnot(a)   return MODM - a end
local bnot = M.bnot

function M.band(a,b) return ((a+b) - bxor(a,b))/2 end
local band = M.band

function M.bor(a,b)  return MODM - band(MODM - a, MODM - b) end
local bor = M.bor

local lshift, rshift -- forward declare

function M.rshift(a,disp) -- Lua5.2 insipred
  if disp < 0 then return lshift(a,-disp) end
  return floor(a % 2^32 / 2^disp)
end
rshift = M.rshift

function M.lshift(a,disp) -- Lua5.2 inspired
  if disp < 0 then return rshift(a,-disp) end
  return (a * 2^disp) % 2^32
end
lshift = M.lshift

function M.tohex(x, n) -- BitOp style
  n = n or 8
  local up
  if n <= 0 then
    if n == 0 then return '' end
    up = true
    n = - n
  end
  x = band(x, 16^n-1)
  return ('%0'..n..(up and 'X' or 'x')):format(x)
end
local tohex = M.tohex

function M.extract(n, field, width) -- Lua5.2 inspired
  width = width or 1
  return band(rshift(n, field), 2^width-1)
end
local extract = M.extract

function M.replace(n, v, field, width) -- Lua5.2 inspired
  width = width or 1
  local mask1 = 2^width-1
  v = band(v, mask1) -- required by spec?
  local mask = bnot(lshift(mask1, field))
  return band(n, mask) + lshift(v, field)
end
local replace = M.replace

function M.bswap(x)  -- BitOp style
  local a = band(x, 0xff); x = rshift(x, 8)
  local b = band(x, 0xff); x = rshift(x, 8)
  local c = band(x, 0xff); x = rshift(x, 8)
  local d = band(x, 0xff)
  return lshift(lshift(lshift(a, 8) + b, 8) + c, 8) + d
end
local bswap = M.bswap

function M.rrotate(x, disp)  -- Lua5.2 inspired
  disp = disp % 32
  local low = band(x, 2^disp-1)
  return rshift(x, disp) + lshift(low, 32-disp)
end
local rrotate = M.rrotate

function M.lrotate(x, disp)  -- Lua5.2 inspired
  return rrotate(x, -disp)
end
local lrotate = M.lrotate

M.rol = M.lrotate  -- LuaOp inspired
M.ror = M.rrotate  -- LuaOp insipred


function M.arshift(x, disp) -- Lua5.2 inspired
  local z = rshift(x, disp)
  if x >= 0x80000000 then z = z + lshift(2^disp-1, 32-disp) end
  return z
end
local arshift = M.arshift

function M.btest(x, y) -- Lua5.2 inspired
  return band(x, y) ~= 0
end

--
-- Start Lua 5.2 "bit32" compat section.
--

M.bit32 = {} -- Lua 5.2 'bit32' compatibility

M.bit32.bits = M.bits

M.bit32.cast = M.cast

local function bit32_bnot(x)
  return (-1 - x) % MOD
end
M.bit32.bnot = bit32_bnot

local function bit32_bxor(a, b, c, ...)
  local z
  if b then
    a = a % MOD
    b = b % MOD
    z = bxor(a, b)
    if c then
      z = bit32_bxor(z, c, ...)
    end
    return z
  elseif a then
    return a % MOD
  else
    return 0
  end
end
M.bit32.bxor = bit32_bxor

local function bit32_band(a, b, c, ...)
  local z
  if b then
    a = a % MOD
    b = b % MOD
    z = ((a+b) - bxor(a,b)) / 2
    if c then
      z = bit32_band(z, c, ...)
    end
    return z
  elseif a then
    return a % MOD
  else
    return MODM
  end
end
M.bit32.band = bit32_band

local function bit32_bor(a, b, c, ...)
  local z
  if b then
    a = a % MOD
    b = b % MOD
    z = MODM - band(MODM - a, MODM - b)
    if c then
      z = bit32_bor(z, c, ...)
    end
    return z
  elseif a then
    return a % MOD
  else
    return 0
  end
end
M.bit32.bor = bit32_bor

function M.bit32.btest(...)
  return bit32_band(...) ~= 0
end

function M.bit32.lrotate(x, disp)
  return lrotate(x % MOD, disp)
end

function M.bit32.rrotate(x, disp)
  return rrotate(x % MOD, disp)
end

function M.bit32.lshift(x,disp)
  if disp > 31 or disp < -31 then return 0 end
  return lshift(x % MOD, disp)
end

function M.bit32.rshift(x,disp)
  if disp > 31 or disp < -31 then return 0 end
  return rshift(x % MOD, disp)
end

function M.bit32.arshift(x,disp)
  x = x % MOD
  if disp >= 0 then
    if disp > 31 then
      return (x >= 0x80000000) and MODM or 0
    else
      local z = rshift(x, disp)
      if x >= 0x80000000 then z = z + lshift(2^disp-1, 32-disp) end
      return z
    end
  else
    return lshift(x, -disp)
  end
end

function M.bit32.extract(x, field, ...)
  local width = ... or 1
  if field < 0 or field > 31 or width < 0 or field+width > 32 then error 'out of range' end
  x = x % MOD
  return extract(x, field, ...)
end

function M.bit32.replace(x, v, field, ...)
  local width = ... or 1
  if field < 0 or field > 31 or width < 0 or field+width > 32 then error 'out of range' end
  x = x % MOD
  v = v % MOD
  return replace(x, v, field, ...)
end


--
-- Start LuaBitOp "bit" compat section.
--

M.bit = {} -- LuaBitOp "bit" compatibility

M.bit.bits = M.bits

M.bit.cast = M.cast

function M.bit.tobit(x)
  x = x % MOD
  if x >= 0x80000000 then x = x - MOD end
  return x
end
local bit_tobit = M.bit.tobit

function M.bit.tohex(x, ...)
  return tohex(x % MOD, ...)
end

function M.bit.bnot(x)
  return bit_tobit(bnot(x % MOD))
end

local function bit_bor(a, b, c, ...)
  if c then
    return bit_bor(bit_bor(a, b), c, ...)
  elseif b then
    return bit_tobit(bor(a % MOD, b % MOD))
  else
    return bit_tobit(a)
  end
end
M.bit.bor = bit_bor

local function bit_band(a, b, c, ...)
  if c then
    return bit_band(bit_band(a, b), c, ...)
  elseif b then
    return bit_tobit(band(a % MOD, b % MOD))
  else
    return bit_tobit(a)
  end
end
M.bit.band = bit_band

local function bit_bxor(a, b, c, ...)
  if c then
    return bit_bxor(bit_bxor(a, b), c, ...)
  elseif b then
    return bit_tobit(bxor(a % MOD, b % MOD))
  else
    return bit_tobit(a)
  end
end
M.bit.bxor = bit_bxor

function M.bit.lshift(x, n)
  return bit_tobit(lshift(x % MOD, n % 32))
end

function M.bit.rshift(x, n)
  return bit_tobit(rshift(x % MOD, n % 32))
end

function M.bit.arshift(x, n)
  return bit_tobit(arshift(x % MOD, n % 32))
end

function M.bit.rol(x, n)
  return bit_tobit(lrotate(x % MOD, n % 32))
end

function M.bit.ror(x, n)
  return bit_tobit(rrotate(x % MOD, n % 32))
end

function M.bit.bswap(x)
  return bit_tobit(bswap(x % MOD))
end

return M
]]></ProtectedString>
                            <BinaryString name="Tags"></BinaryString>
                        </Properties>
                    </Item>
                </Item>
            </Item>
            <Item class="ModuleScript" referent="RBX4b14a91351d1404f89ac5d7683abdde5">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">Logger</string>
                    <string name="ScriptGuid"></string>
                    <ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
--local GameAnalyticsSendMessage

local logger = {
    _infoLogEnabled = false,
    _infoLogAdvancedEnabled = false,
    _debugEnabled = RunService:IsStudio()
}

function logger:setDebugLog(enabled)
    self._debugEnabled = enabled
end

function logger:setInfoLog(enabled)
    self._infoLogEnabled = enabled
end

function logger:setVerboseLog(enabled)
    self._infoLogAdvancedEnabled = enabled
end

function logger:i(format)
    if not self._infoLogEnabled then
        return
    end

    local m = "Info/GameAnalytics: " .. format
    print(m)
--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
--    GameAnalyticsSendMessage:FireAllClients({
--        Text = m,
--        Font = Enum.Font.Arial,
--        Color = Color3.new(255, 255, 255),
--        FontSize = Enum.FontSize.Size96
--    })
end

function logger:w(format)
    local m = "Warning/GameAnalytics: " .. format
    warn(m)
--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
--    GameAnalyticsSendMessage:FireAllClients({
--        Text = m,
--        Font = Enum.Font.Arial,
--        Color = Color3.new(255, 255, 0),
--        FontSize = Enum.FontSize.Size96
--    })
end

function logger:e(format)
    spawn(function ()
        local m = "Error/GameAnalytics: " .. format
        error(m, 0)
--        GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
--        GameAnalyticsSendMessage:FireAllClients({
--            Text = m,
--            Font = Enum.Font.Arial,
--            Color = Color3.new(255, 0, 0),
--            FontSize = Enum.FontSize.Size96
--        })
    end)
end

function logger:d(format)
    if not self._debugEnabled then
        return
    end

    local m = "Debug/GameAnalytics: " .. format
    print(m)
--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
--    GameAnalyticsSendMessage:FireAllClients({
--        Text = m,
--        Font = Enum.Font.Arial,
--        Color = Color3.new(255, 255, 255),
--        FontSize = Enum.FontSize.Size96
--    })
end

function logger:ii(format)
    if not self._infoLogAdvancedEnabled then
        return
    end

    local m = "Verbose/GameAnalytics: " .. format
    print(m)
--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
--    GameAnalyticsSendMessage:FireAllClients({
--        Text = m,
--        Font = Enum.Font.Arial,
--        Color = Color3.new(255, 255, 255),
--        FontSize = Enum.FontSize.Size96
--    })
end

return logger
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
            </Item>
            <Item class="ModuleScript" referent="RBX0fd16702bea24d64882fe169a7f9157d">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">Store</string>
                    <string name="ScriptGuid"></string>
                    <ProtectedString name="Source"><![CDATA[local DS = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")

local store = {
    PlayerDS = RunService:IsStudio() and {} or DS:GetDataStore("GA_PlayerDS_1.0.0"),
    AutoSaveData = 180, --Set to 0 to disable
    BasePlayerData = {
        Sessions = 0,
        Transactions = 0,
        ProgressionTries = {},
        CurrentCustomDimension01 = "",
        CurrentCustomDimension02 = "",
        CurrentCustomDimension03 = "",
        InitAuthorized = false,
        SdkConfig = {},
        ClientServerTimeOffset = 0,
        Configurations = {},
        CommandCenterIsReady = false,
        PlayerTeleporting = false
    },
    DataToSave = {
        "Sessions",
        "Transactions",
        "ProgressionTries",
        "CurrentCustomDimension01",
        "CurrentCustomDimension02",
        "CurrentCustomDimension03"
    },

    --Cache
    PlayerCache = {},
    EventsQueue = {}
}

function store:GetPlayerData(Player)
    local PlayerData
    local success, _ = pcall(function()
        PlayerData = RunService:IsStudio() and {} or (store.PlayerDS:GetAsync(Player.UserId) or {})
    end)

    if not success then
        PlayerData = {}
    end

    return PlayerData
end

function store:GetErrorDataStore(scope)
    local ErrorDS
    local success, _ = pcall(function()
        ErrorDS = RunService:IsStudio() and {} or DS:GetDataStore("GA_ErrorDS_1.0.0", scope)
    end)

    if not success then
        ErrorDS = {}
    end

    return ErrorDS
end

function store:SavePlayerData(Player)

    --Variables
    local PlayerData = store.PlayerCache[Player.UserId]
    local SavePlayerData = {}

    if not PlayerData then
        return
    end

    --Fill
    for _, key in pairs(store.DataToSave) do
        SavePlayerData[key] = PlayerData[key]
    end

    --Save
    if not RunService:IsStudio() then
        pcall(function()
            store.PlayerDS:SetAsync(Player.UserId, SavePlayerData)
        end)
    end
end

function store:IncrementErrorCount(ErrorDS, ErrorKey, step)
    if not ErrorKey then
        return
    end

    local count = 0
    --Increment count
    if not RunService:IsStudio() then
        pcall(function()
            count = ErrorDS:IncrementAsync(ErrorKey, step)
        end)
    end

    return count
end

return store
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
            </Item>
            <Item class="ModuleScript" referent="RBXbba5a886fb3443b989529266284f613e">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">Events</string>
                    <string name="ScriptGuid"></string>
                    <ProtectedString name="Source"><![CDATA[local events = {
    ProcessEventsInterval = 8,
    GameKey = "",
    SecretKey = "",
    _build = "",
    _availableResourceCurrencies = {},
    _availableResourceItemTypes = {},
}

local store = require(script.Parent.Store)
local logger = require(script.Parent.Logger)
local version = require(script.Parent.Version)
local validation = require(script.Parent.Validation)
local threading = require(script.Parent.Threading)
local http_api = require(script.Parent.HttpApi)
local utilities = require(script.Parent.Utilities)
local GAResourceFlowType = require(script.Parent.GAResourceFlowType)
local GAProgressionStatus = require(script.Parent.GAProgressionStatus)
local GAErrorSeverity = require(script.Parent.GAErrorSeverity)
local HTTP = game:GetService("HttpService")

local CategorySessionStart = "user"
local CategorySessionEnd = "session_end"
local CategoryBusiness = "business"
local CategoryResource = "resource"
local CategoryProgression = "progression"
local CategoryDesign = "design"
local CategoryError = "error"
local MAX_EVENTS_TO_SEND_IN_ONE_BATCH = 500
local MAX_AGGREGATED_EVENTS = 2000



local function addDimensionsToEvent(playerId, eventData)
    if not eventData then
        return
    end

    if not playerId then
        return
    end

    local PlayerData = store.PlayerCache[playerId]

    -- add to dict (if not nil)
    if PlayerData and PlayerData.CurrentCustomDimension01 and #PlayerData.CurrentCustomDimension01 > 0 then
        eventData["custom_01"] = PlayerData.CurrentCustomDimension01
    end
    if PlayerData and PlayerData.CurrentCustomDimension02 and #PlayerData.CurrentCustomDimension02 > 0 then
        eventData["custom_02"] = PlayerData.CurrentCustomDimension02
    end
    if PlayerData and PlayerData.CurrentCustomDimension03 and #PlayerData.CurrentCustomDimension03 > 0 then
        eventData["custom_03"] = PlayerData.CurrentCustomDimension03
    end
end

local function getClientTsAdjusted(playerId)
    if not playerId then
        return os.time()
    end
    local PlayerData = store.PlayerCache[playerId]
    local clientTs = os.time()
    local clientTsAdjustedInteger = clientTs + PlayerData.ClientServerTimeOffset
    if validation:validateClientTs(clientTsAdjustedInteger) then
        return clientTsAdjustedInteger;
    else
        return clientTs
    end
end

local DUMMY_SESSION_ID = HTTP:GenerateGUID(false):lower()

local function getEventAnnotations(playerId)
    local PlayerData
    local id

    if playerId then
        id = playerId
        PlayerData = store.PlayerCache[playerId]
    else
        id = "DummyId"
        PlayerData = {
            OS = "uwp_desktop 0.0.0",
            Platform = "uwp_desktop",
            SessionID = DUMMY_SESSION_ID,
            Sessions = 1
        }
    end

    local annotations = {
        -- ---- REQUIRED ----
        -- collector event API version
        ["v"] = 2,
        -- User identifier
        ["user_id"] = tostring(id),
        -- Client Timestamp (the adjusted timestamp)
        ["client_ts"] = getClientTsAdjusted(playerId),
        -- SDK version
        ["sdk_version"] = "roblox " .. version.SdkVersion,
        -- Operation system version
        ["os_version"] = PlayerData.OS,
        -- Device make (hardcoded to apple)
        ["manufacturer"] = "unknown",
        -- Device version
        ["device"] = "unknown",
        -- Platform (operating system)
        ["platform"] = PlayerData.Platform,
        -- Session identifier
        ["session_id"] = PlayerData.SessionID,
        -- Session number
        ["session_num"] = PlayerData.Sessions
    }

    if validation:validateBuild(events._build) then
        annotations["build"] = events._build
    end

    return annotations
end

local function addEventToStore(playerId, eventData)
    -- Get default annotations
    local ev = getEventAnnotations(playerId)

    -- Merge with eventData
    for k,_ in pairs(eventData) do
        ev[k] = eventData[k]
    end

    -- Create json string representation
    local json = HTTP:JSONEncode(ev)

    -- output if VERBOSE LOG enabled
    logger:ii("Event added to queue: " .. json)

    -- Add to store
    store.EventsQueue[#store.EventsQueue + 1] = ev
end

local function dequeueMaxEvents()
    if #store.EventsQueue <= MAX_EVENTS_TO_SEND_IN_ONE_BATCH then
        local eventsQueue = store.EventsQueue
        store.EventsQueue = {}
        return eventsQueue
    else
        logger:w(("More than %d events queued! Sending %d."):format(MAX_EVENTS_TO_SEND_IN_ONE_BATCH, MAX_EVENTS_TO_SEND_IN_ONE_BATCH))

        if #self.EventsQueue > MAX_AGGREGATED_EVENTS then
            logger:w(("DROPPING EVENTS: More than %d events queued!"):format(MAX_AGGREGATED_EVENTS))
        end

        -- Expensive operation to get ordered events cleared out (O(n))
        local eventsQueue = {}
        for i=1, MAX_EVENTS_TO_SEND_IN_ONE_BATCH do
            eventsQueue[i] = store.EventsQueue[i]
        end

        -- Shift everything down and overwrite old events
        local eventCount = #self._events
        for i=1, math.min(MAX_AGGREGATED_EVENTS, eventCount) do
            store.EventsQueue[i] = store.EventsQueue[i + MAX_EVENTS_TO_SEND_IN_ONE_BATCH]
        end

        -- Clear additional events
        for i=MAX_AGGREGATED_EVENTS+1, eventCount do
            store.EventsQueue[i] = nil
        end

        return eventsQueue
    end
end

local function processEvents()
    local queue = dequeueMaxEvents()

    if #queue == 0 then
        logger:i("Event queue: No events to send")
        return
    end

    -- Log
    logger:i("Event queue: Sending " .. tostring(#queue) .. " events.")

    local eventsResult = http_api:sendEventsInArray(events.GameKey, events.SecretKey, queue)
    local statusCode = eventsResult.statusCode
    local responseBody = eventsResult.body

    if statusCode == http_api.EGAHTTPApiResponse.Ok and responseBody then
        logger:i("Event queue: " .. tostring(#queue) .. " events sent.")
    else
        if statusCode == http_api.EGAHTTPApiResponse.NoResponse then
            logger:w("Event queue: Failed to send events to collector - Retrying next time")
            for _,e in pairs(queue) do
                if #store.EventsQueue < MAX_AGGREGATED_EVENTS then
                    store.EventsQueue[#store.EventsQueue + 1] = e
                else
                    break
                end
            end
        else
            if statusCode == http_api.EGAHTTPApiResponse.BadRequest and responseBody then
                logger:w("Event queue: " .. tostring(#queue) .. " events sent. " .. tostring(#responseBody) .. " events failed GA server validation.")
            else
                logger:w("Event queue: Failed to send events.")
            end
        end
    end
end

function events:processEventQueue()
    processEvents()
    threading:scheduleTimer(events.ProcessEventsInterval, function()
        events:processEventQueue()
    end)
end

function events:setBuild(build)
    if not validation:validateBuild(build) then
        logger:w("Validation fail - configure build: Cannot be null, empty or above 32 length. String: " .. build)
        return
    end

    self._build = build
    logger:i("Set build version: " .. build)
end

function events:setAvailableResourceCurrencies(availableResourceCurrencies)
    if not validation:validateResourceCurrencies(availableResourceCurrencies) then
        return
    end

    self._availableResourceCurrencies = availableResourceCurrencies

    logger:i("Set available resource currencies: (" .. table.concat(availableResourceCurrencies, ", ") .. ")")
end

function events:setAvailableResourceItemTypes(availableResourceItemTypes)
    if not validation:validateResourceCurrencies(availableResourceItemTypes) then
        return
    end

    self._availableResourceItemTypes = availableResourceItemTypes

    logger:i("Set available resource item types: (" .. table.concat(availableResourceItemTypes, ", ") .. ")")
end

function events:addSessionStartEvent(playerId, teleportData)
    local PlayerData = store.PlayerCache[playerId]

    if teleportData then
        PlayerData.Sessions = teleportData.Sessions
    else
        local eventDict = {}

        -- Event specific data
        eventDict["category"] = CategorySessionStart

        -- Increment session number  and persist
        PlayerData.Sessions = PlayerData.Sessions + 1

        --  Add custom dimensions
        addDimensionsToEvent(playerId, eventDict)

        -- Add to store
        addEventToStore(playerId, eventDict)

        logger:i("Add SESSION START event")

        processEvents()
    end
end

function events:addSessionEndEvent(playerId)
    local PlayerData = store.PlayerCache[playerId]
    local session_start_ts = PlayerData.SessionStart
    local client_ts_adjusted = getClientTsAdjusted(playerId)
    local sessionLength = client_ts_adjusted - session_start_ts

    if sessionLength < 0 then
        -- Should never happen.
        -- Could be because of edge cases regarding time altering on device.
        logger:w("Session length was calculated to be less then 0. Should not be possible. Resetting to 0.")
        sessionLength = 0
    end

    -- Event specific data
    local eventDict = {}
    eventDict["category"] = CategorySessionEnd
    eventDict["length"] = sessionLength

    -- Add custom dimensions
    addDimensionsToEvent(playerId, eventDict)

    -- Add to store
    addEventToStore(playerId, eventDict)

    logger:i("Add SESSION END event.")

    processEvents()
end

function events:addBusinessEvent(playerId, currency, amount, itemType, itemId, cartType)
    -- Validate event params
    if not validation:validateBusinessEvent(currency, amount, cartType, itemType, itemId) then
        -- TODO: add sdk error event
        return
    end

    -- Create empty eventData
    local eventDict = {}

    -- Increment transaction number and persist
    local PlayerData = store.PlayerCache[playerId]
    PlayerData.Transactions = PlayerData.Transactions + 1

    -- Required
    eventDict["event_id"] = itemType .. ":" .. itemId
    eventDict["category"] = CategoryBusiness
    eventDict["currency"] = currency
    eventDict["amount"] = amount
    eventDict["transaction_num"] = PlayerData.Transactions

    -- Optional
    if not utilities:isStringNullOrEmpty(cartType) then
        eventDict["cart_type"] = cartType
    end

    -- Add custom dimensions
    addDimensionsToEvent(playerId, eventDict)

    logger:i("Add BUSINESS event: {currency:" .. currency .. ", amount:" .. tostring(amount) .. ", itemType:" .. itemType .. ", itemId:" .. itemId .. ", cartType:" .. cartType .. "}")

    -- Send to store
    addEventToStore(playerId, eventDict)
end

function events:addResourceEvent(playerId, flowType, currency, amount, itemType, itemId)
    -- Validate event params
    if not validation:validateResourceEvent(GAResourceFlowType, flowType, currency, amount, itemType, itemId, self._availableResourceCurrencies, self._availableResourceItemTypes) then
        -- TODO: add sdk error event
        return
    end

    -- If flow type is sink reverse amount
    if flowType == GAResourceFlowType.Sink then
        amount = (-1 * amount)
    end

    -- Create empty eventData
    local eventDict = {}

    -- insert event specific values
    local flowTypeString = GAResourceFlowType[flowType]
    eventDict["event_id"] = flowTypeString .. ":" .. currency .. ":" .. itemType .. ":" .. itemId
    eventDict["category"] = CategoryResource
    eventDict["amount"] = amount

    -- Add custom dimensions
    addDimensionsToEvent(playerId, eventDict)

    logger:i("Add RESOURCE event: {currency:" .. currency .. ", amount:" .. tostring(amount) .. ", itemType:" .. itemType .. ", itemId:" .. itemId .. "}")

    -- Send to store
    addEventToStore(playerId, eventDict)
end

function events:addProgressionEvent(playerId, progressionStatus, progression01, progression02, progression03, score)
    -- Validate event params
    if not validation:validateProgressionEvent(GAProgressionStatus, progressionStatus, progression01, progression02, progression03) then
        -- TODO: add sdk error event
        return
    end

    -- Create empty eventData
    local eventDict = {}

    -- Progression identifier
    local progressionIdentifier
    if utilities:isStringNullOrEmpty(progression02) then
        progressionIdentifier = progression01
    elseif utilities:isStringNullOrEmpty(progression03) then
        progressionIdentifier = progression01 .. ":" .. progression02
    else
        progressionIdentifier = progression01 .. ":" .. progression02 .. ":" .. progression03
    end

    local statusString = GAProgressionStatus[progressionStatus]

    -- Append event specifics
    eventDict["category"] = CategoryProgression
    eventDict["event_id"] = statusString .. ":" .. progressionIdentifier

    -- Attempt
    local attempt_num = 0

    -- Add score if specified and status is not start
    if score ~= nil and progressionStatus ~= GAProgressionStatus.Start then
        eventDict["score"] = score
    end

    local PlayerData = store.PlayerCache[playerId]

    -- Count attempts on each progression fail and persist
    if progressionStatus == GAProgressionStatus.Fail then
        -- Increment attempt number
        local progressionTries = PlayerData.ProgressionTries[progressionIdentifier] or 0
        PlayerData.ProgressionTries[progressionIdentifier] = progressionTries + 1
    end

    -- increment and add attempt_num on complete and delete persisted
    if progressionStatus == GAProgressionStatus.Complete then
        -- Increment attempt number
        local progressionTries = PlayerData.ProgressionTries[progressionIdentifier] or 0
        PlayerData.ProgressionTries[progressionIdentifier] = progressionTries + 1

        -- Add to event
        attempt_num = PlayerData.ProgressionTries[progressionIdentifier]
        eventDict["attempt_num"] = attempt_num

        -- Clear
        PlayerData.ProgressionTries[progressionIdentifier] = 0
    end

    -- Add custom dimensions
    addDimensionsToEvent(playerId, eventDict)

    logger:i("Add PROGRESSION event: {status:" .. statusString .. ", progression01:" .. progression01 .. ", progression02:" .. progression02 .. ", progression03:" .. progression03 .. ", score:" .. tostring(score) .. ", attempt:" .. tostring(attempt_num) .. "}")

    -- Send to store
    addEventToStore(playerId, eventDict)
end

function events:addDesignEvent(playerId, eventId, value)
    -- Validate
    if not validation:validateDesignEvent(eventId) then
        -- TODO: add sdk error event
        return
    end

    -- Create empty eventData
    local eventData = {}

    -- Append event specifics
    eventData["category"] = CategoryDesign
    eventData["event_id"] = eventId

    if value ~= nil then
        eventData["value"] = value
    end

    -- Add custom dimensions
    addDimensionsToEvent(playerId, eventData)

    logger:i("Add DESIGN event: {eventId:" .. eventId .. ", value:" .. tostring(value) .. "}")

    -- Send to store
    addEventToStore(playerId, eventData)
end

function events:addErrorEvent(playerId, severity, message)
    -- Validate
    if not validation:validateErrorEvent(GAErrorSeverity, severity, message) then
        -- TODO: add sdk error event
        return
    end

    -- Create empty eventData
    local eventData = {}

    local severityString = GAErrorSeverity[severity]

    eventData["category"] = CategoryError
    eventData["severity"] = severityString
    eventData["message"] = message

    -- Add custom dimensions
    addDimensionsToEvent(playerId, eventData)

    logger:i("Add ERROR event: {severity:" .. severityString .. ", message:" .. message .. "}")

    -- Send to store
    addEventToStore(playerId, eventData)
end

return events
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
            </Item>
            <Item class="ModuleScript" referent="RBX5190ffbee57e4a9b94c4e0a74eb63cab">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">Utilities</string>
                    <string name="ScriptGuid"></string>
                    <ProtectedString name="Source"><![CDATA[local utilities = {}

function utilities:isStringNullOrEmpty(s)
    return (not s) or #s == 0
end

function utilities:stringArrayContainsString(array, search)
    if #array == 0 then
        return false
    end

    for _,s in pairs(array) do
        if s == search then
            return true
        end
    end

    return false
end

return utilities
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
            </Item>
            <Item class="ModuleScript" referent="RBX02095c98e62847afaf7fdea69dab9f66">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">Version</string>
                    <string name="ScriptGuid">{08f3dc9a-fca3-4b1b-8436-e07880f9095e}</string>
                    <ProtectedString name="Source"><![CDATA[local version = {
    SdkVersion = "1.3.6"
}

return version
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
            </Item>
            <Item class="ModuleScript" referent="RBX8bd464ce27cb4e64ab219c6cb8ccb43d">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">State</string>
                    <string name="ScriptGuid"></string>
                    <ProtectedString name="Source"><![CDATA[local state = {
    _availableCustomDimensions01 = {},
    _availableCustomDimensions02 = {},
    _availableCustomDimensions03 = {},
    _enableEventSubmission = true,
    Initialized = false,
    ReportErrors = true,
    AutomaticSendBusinessEvents = true
}

local validation = require(script.Parent.Validation)
local logger = require(script.Parent.Logger)
local http_api = require(script.Parent.HttpApi)
local store = require(script.Parent.Store)
local events = require(script.Parent.Events)
local HTTP = game:GetService("HttpService")
local GameAnalyticsCommandCenter

local function getClientTsAdjusted(playerId)
    local PlayerData = store.PlayerCache[playerId]
    if not PlayerData then
        return os.time()
    end
    local clientTs = os.time()
    local clientTsAdjustedInteger = clientTs + PlayerData.ClientServerTimeOffset
    if validation:validateClientTs(clientTsAdjustedInteger) then
        return clientTsAdjustedInteger;
    else
        return clientTs
    end
end

local function populateConfigurations(player)
    local PlayerData = store.PlayerCache[player.UserId]
    local sdkConfig = PlayerData.SdkConfig

    if sdkConfig["configurations"] then
        local configurations = sdkConfig["configurations"]

        for _,configuration in pairs(configurations) do
            if configuration then
                local key = configuration["key"] or ""
                local start_ts = configuration["start"] or 0
                local end_ts = configuration["end"] or math.huge
                local client_ts_adjusted = getClientTsAdjusted(player.UserId)

                if #key > 0 and configuration["value"] and client_ts_adjusted > start_ts and client_ts_adjusted < end_ts then
                    PlayerData.Configurations[key] = configuration["value"]
                    logger:d("configuration added: key=" .. configuration["key"] .. ", value=" .. configuration["value"])
                end
            end
        end
    end

    PlayerData.CommandCenterIsReady = true
    GameAnalyticsCommandCenter = GameAnalyticsCommandCenter or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsCommandCenter")
    GameAnalyticsCommandCenter:FireClient(player, PlayerData.Configurations)
end

function state:sessionIsStarted(playerId)
    local PlayerData = store.PlayerCache[playerId]
    if not PlayerData then
        return false
    end
    return PlayerData.SessionStart ~= 0
end

function state:isEnabled(playerId)
    local PlayerData = store.PlayerCache[playerId]
    if not PlayerData then
        return false
    elseif PlayerData.SdkConfig and PlayerData.SdkConfig["enabled"] == false then
        return false
    elseif not PlayerData.InitAuthorized then
        return false
    else
        return true
    end
end

function state:validateAndFixCurrentDimensions(playerId)
    local PlayerData = store.PlayerCache[playerId]

    -- validate that there are no current dimension01 not in list
    if not validation:validateDimension(self._availableCustomDimensions01, PlayerData.CurrentCustomDimension01) then
        logger:d("Invalid dimension01 found in variable. Setting to nil. Invalid dimension: " .. PlayerData.CurrentCustomDimension01)
    end
    -- validate that there are no current dimension02 not in list
    if not validation:validateDimension(self._availableCustomDimensions02, PlayerData.CurrentCustomDimension02) then
        logger:d("Invalid dimension02 found in variable. Setting to nil. Invalid dimension: " .. PlayerData.CurrentCustomDimension02)
    end
    -- validate that there are no current dimension03 not in list
    if not validation:validateDimension(self._availableCustomDimensions03, PlayerData.CurrentCustomDimension03) then
        logger:d("Invalid dimension03 found in variable. Setting to nil. Invalid dimension: " .. PlayerData.CurrentCustomDimension03)
    end
end

function state:setAvailableCustomDimensions01(availableCustomDimensions)
    if not validation:validateCustomDimensions(availableCustomDimensions) then
        return
    end

    self._availableCustomDimensions01 = availableCustomDimensions

    logger:i("Set available custom01 dimension values: (" .. table.concat(availableCustomDimensions, ", ") .. ")")
end

function state:setAvailableCustomDimensions02(availableCustomDimensions)
    if not validation:validateCustomDimensions(availableCustomDimensions) then
        return
    end

    self._availableCustomDimensions02 = availableCustomDimensions

    logger:i("Set available custom02 dimension values: (" .. table.concat(availableCustomDimensions, ", ") .. ")")
end

function state:setAvailableCustomDimensions03(availableCustomDimensions)
    if not validation:validateCustomDimensions(availableCustomDimensions) then
        return
    end

    self._availableCustomDimensions03 = availableCustomDimensions

    logger:i("Set available custom03 dimension values: (" .. table.concat(availableCustomDimensions, ", ") .. ")")
end

function state:setEventSubmission(flag)
    self._enableEventSubmission = flag
end

function state:isEventSubmissionEnabled()
    return self._enableEventSubmission
end

function state:setCustomDimension01(playerId, dimension)
    local PlayerData = store.PlayerCache[playerId]
    PlayerData.CurrentCustomDimension01 = dimension
end

function state:setCustomDimension02(playerId, dimension)
    local PlayerData = store.PlayerCache[playerId]
    PlayerData.CurrentCustomDimension02 = dimension
end

function state:setCustomDimension03(playerId, dimension)
    local PlayerData = store.PlayerCache[playerId]
    PlayerData.CurrentCustomDimension03 = dimension
end

function state:startNewSession(player, teleportData)
    if state:isEventSubmissionEnabled() then
        logger:i("Starting a new session.")
    end
    local PlayerData = store.PlayerCache[player.UserId]

    -- make sure the current custom dimensions are valid
    state:validateAndFixCurrentDimensions(player.UserId)

    local initResult = http_api:initRequest(events.GameKey, events.SecretKey, PlayerData, player.UserId)
    local statusCode = initResult.statusCode
    local responseBody = initResult.body

    if statusCode == http_api.EGAHTTPApiResponse.Ok and responseBody then
        -- set the time offset - how many seconds the local time is different from servertime
        local timeOffsetSeconds = 0
        local serverTs = responseBody["server_ts"] or -1
        if serverTs > 0 then
            local clientTs = os.time()
            timeOffsetSeconds = serverTs - clientTs
        end

        responseBody["time_offset"] = timeOffsetSeconds

        PlayerData.SdkConfig = responseBody
        PlayerData.InitAuthorized = true
    elseif statusCode == http_api.EGAHTTPApiResponse.Unauthorized then
        logger:w("Initialize SDK failed - Unauthorized")
        PlayerData.InitAuthorized = false
    else
        -- log the status if no connection
        if statusCode == http_api.EGAHTTPApiResponse.NoResponse or statusCode == http_api.EGAHTTPApiResponse.RequestTimeout then
            logger:i("Init call (session start) failed - no response. Could be offline or timeout.")
        elseif statusCode == http_api.EGAHTTPApiResponse.BadResponse or statusCode == http_api.EGAHTTPApiResponse.JsonEncodeFailed or statusCode == http_api.EGAHTTPApiResponse.JsonDecodeFailed then
            logger:i("Init call (session start) failed - bad response. Could be bad response from proxy or GA servers.")
        elseif statusCode == http_api.EGAHTTPApiResponse.BadRequest or statusCode == http_api.EGAHTTPApiResponse.UnknownResponseCode then
            logger:i("Init call (session start) failed - bad request or unknown response.")
        end

        PlayerData.InitAuthorized = true
    end

    -- set offset in state (memory) from current config (config could be from cache etc.)
    PlayerData.ClientServerTimeOffset = PlayerData.SdkConfig["time_offset"] or 0

    -- populate configurations
    populateConfigurations(player)

    if not state:isEnabled(player.UserId) then
        logger:w("Could not start session: SDK is disabled.")
        return
    end

    if teleportData then
        PlayerData.SessionID = teleportData.SessionID
        PlayerData.SessionStart = teleportData.SessionStart
    else
        PlayerData.SessionID = HTTP:GenerateGUID(false):lower()
        PlayerData.SessionStart = getClientTsAdjusted(player.UserId)
    end

    if state:isEventSubmissionEnabled() then
        events:addSessionStartEvent(player.UserId, teleportData)
    end
end

function state:endSession(playerId)
    if state.Initialized and state:isEventSubmissionEnabled() then
        logger:i("Ending session.")
        if state:isEnabled(playerId) and state:sessionIsStarted(playerId) then
            events:addSessionEndEvent(playerId)
            store.PlayerCache[playerId] = nil
        end
    end
end

function state:getConfigurationStringValue(playerId, key, defaultValue)
    local PlayerData = store.PlayerCache[playerId]
    return PlayerData.Configurations[key] or defaultValue
end

function state:isCommandCenterReady(playerId)
    local PlayerData = store.PlayerCache[playerId]
    return PlayerData.CommandCenterIsReady
end

function state:getConfigurationsContentAsString(playerId)
    local PlayerData = store.PlayerCache[playerId]
    return HTTP:JSONEncode(PlayerData.Configurations)
end

return state
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
            </Item>
            <Item class="ModuleScript" referent="RBX4f67f666894641cf9fa8b191f2a175c9">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">Validation</string>
                    <string name="ScriptGuid"></string>
                    <ProtectedString name="Source"><![CDATA[local validation = {}

local logger = require(script.Parent.Logger)
local utilities = require(script.Parent.Utilities)

function validation:validateCustomDimensions(customDimensions)
    return validation:validateArrayOfStrings(20, 32, false, "custom dimensions", customDimensions)
end

function validation:validateDimension(dimensions, dimension)
    -- allow nil
    if utilities:isStringNullOrEmpty(dimension) then
        return true
    end

    if not utilities:stringArrayContainsString(dimensions, dimension) then
        return false
    end

    return true
end

function validation:validateResourceCurrencies(resourceCurrencies)
    if not validation:validateArrayOfStrings(20, 64, false, "resource currencies", resourceCurrencies) then
        return false
    end

    -- validate each string for regex
    for _,resourceCurrency in pairs(resourceCurrencies) do
        if not string.find(resourceCurrency, "^[A-Za-z]+$") then
            logger:w("resource currencies validation failed: a resource currency can only be A-Z, a-z. String was: " .. resourceCurrency)
            return false
        end
    end

    return true
end

function validation:validateResourceItemTypes(resourceItemTypes)
    if not validation:validateArrayOfStrings(20, 32, false, "resource item types", resourceItemTypes) then
        return false
    end

    -- validate each string for regex
    for _,resourceItemType in pairs(resourceItemTypes) do
        if not validation:validateEventPartCharacters(resourceItemType) then
            logger:w("resource item types validation failed: a resource item type cannot contain other characters than A-z, 0-9, -_., ()!?. String was: " .. resourceItemType)
            return false
        end
    end

    return true
end

function validation:validateEventPartCharacters(eventPart)
    if not string.find(eventPart, "^[A-Za-z0-9%s%-_%.%(%)!%?]+$") then
        return false
    end

    return true
end

function validation:validateArrayOfStrings(maxCount, maxStringLength, allowNoValues, logTag, arrayOfStrings)
    local arrayTag = logTag

    if not arrayTag then
        arrayTag = "Array"
    end

    -- use arrayTag to annotate warning log
    if not arrayOfStrings then
        logger:w(arrayTag .. " validation failed: array cannot be nil.")
        return false
    end

    -- check if empty
    if not allowNoValues and #arrayOfStrings == 0 then
        logger:w(arrayTag .. " validation failed: array cannot be empty.")
        return false
    end

    -- check if exceeding max count
    if maxCount > 0 and #arrayOfStrings > maxCount then
        logger:w(arrayTag .. " validation failed: array cannot exceed " .. tostring(maxCount) .. " values. It has " .. #arrayOfStrings .. " values.")
        return false
    end

    -- validate each string
    for _,arrayString in pairs(arrayOfStrings) do
        local stringLength = 0
        if arrayString then
            stringLength = #arrayString
        end

        -- check if empty (not allowed)
        if stringLength == 0 then
            logger:w(arrayTag .. " validation failed: contained an empty string.")
            return false
        end

        -- check if exceeding max length
        if maxStringLength > 0 and stringLength > maxStringLength then
            logger:w(arrayTag .. " validation failed: a string exceeded max allowed length (which is: " .. tostring(maxStringLength) .. "). String was: " .. arrayString)
            return false
        end
    end

    return true
end

function validation:validateBuild(build)
    if not validation:validateShortString(build, false) then
        return false
    end

    return true
end

function validation:validateShortString(shortString, canBeEmpty)
    -- String is allowed to be empty or nil
    if canBeEmpty and utilities:isStringNullOrEmpty(shortString) then
        return true
    end

    if utilities:isStringNullOrEmpty(shortString) or #shortString > 32 then
        return false
    end

    return true
end

function validation:validateKeys(gameKey, secretKey)
    if string.find(gameKey, "^[A-Za-z0-9]+$") and #gameKey == 32 then
        if string.find(secretKey, "^[A-Za-z0-9]+$") and #secretKey == 40 then
            return true
        end
    end

    return false
end

function validation:validateAndCleanInitRequestResponse(initResponse)
    -- make sure we have a valid dict
    if not initResponse then
        logger:w("validateInitRequestResponse failed - no response dictionary.")
        return nil
    end

    local validatedDict = {}

    -- validate enabled field
    validatedDict["enabled"] = initResponse["enabled"] or true

    -- validate server_ts
    local serverTsNumber = initResponse["server_ts"] or -1
    if serverTsNumber > 0 then
        validatedDict["server_ts"] = serverTsNumber
    end

    validatedDict["configurations"] = initResponse["configurations"] or {}

    return validatedDict
end

function validation:validateClientTs(clientTs)
    if clientTs < 1000000000 or clientTs > 9999999999 then
        return false
    end

    return true
end

function validation:validateCurrency(currency)
    if utilities:isStringNullOrEmpty(currency) then
        return false
    end

    if string.find(currency, "^[A-Z]+$") and #currency == 3 then
        return true
    end
    return false
end

function validation:validateEventPartLength(eventPart, allowNull)
    if allowNull and utilities:isStringNullOrEmpty(eventPart) then
        return true
    end

    if utilities:isStringNullOrEmpty(eventPart) then
        return false
    end

    if #eventPart == 0 or #eventPart > 64 then
        return false
    end
    return true
end

function validation:validateBusinessEvent(currency, amount, cartType, itemType, itemId)
    -- validate currency
    if not validation:validateCurrency(currency) then
        logger:w("Validation fail - business event - currency: Cannot be (null) and need to be A-Z, 3 characters and in the standard at openexchangerates.org. Failed currency: " .. currency)
        return false
    end

    if amount < 0 then
        logger:w("Validation fail - business event - amount: Cannot be less then 0. Failed amount: " .. amount)
        return false
    end

    -- validate cartType
    if not validation:validateShortString(cartType, true) then
        logger:w("Validation fail - business event - cartType. Cannot be above 32 length. String: " .. cartType)
        return false
    end

    -- validate itemType length
    if not validation:validateEventPartLength(itemType, false) then
        logger:w("Validation fail - business event - itemType: Cannot be (null), empty or above 64 characters. String: " .. itemType)
        return false
    end

    -- validate itemType chars
    if not validation:validateEventPartCharacters(itemType) then
        logger:w("Validation fail - business event - itemType: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " .. itemType)
        return false
    end

    -- validate itemId
    if not validation:validateEventPartLength(itemId, false) then
        logger:w("Validation fail - business event - itemId. Cannot be (null), empty or above 64 characters. String: " .. itemId)
        return false
    end

    if not validation:validateEventPartCharacters(itemId) then
        logger:w("Validation fail - business event - itemId: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " .. itemId)
        return false
    end

    return true
end

function validation:validateResourceEvent(flowTypeValues, flowType, currency, amount, itemType, itemId, currencies, itemTypes)
    if flowType ~= flowTypeValues.Source and flowType ~= flowTypeValues.Sink then
        logger:w("Validation fail - resource event - flowType: Invalid flow type " .. tostring(flowType))
        return false
    end

    if utilities:isStringNullOrEmpty(currency) then
        logger:w("Validation fail - resource event - currency: Cannot be (null)")
        return false
    end

    if not utilities:stringArrayContainsString(currencies, currency) then
        logger:w("Validation fail - resource event - currency: Not found in list of pre-defined available resource currencies. String: " .. currency)
        return false
    end

    if not (amount > 0) then
        logger:w("Validation fail - resource event - amount: Float amount cannot be 0 or negative. Value: " .. tostring(amount))
        return false
    end

    if utilities:isStringNullOrEmpty(itemType) then
        logger:w("Validation fail - resource event - itemType: Cannot be (null)")
        return false
    end

    if not validation:validateEventPartLength(itemType, false) then
        logger:w("Validation fail - resource event - itemType: Cannot be (null), empty or above 64 characters. String: " .. itemType)
        return false
    end

    if not validation:validateEventPartCharacters(itemType) then
        logger:w("Validation fail - resource event - itemType: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " .. itemType)
        return false
    end

    if not utilities:stringArrayContainsString(itemTypes, itemType) then
        logger:w("Validation fail - resource event - itemType: Not found in list of pre-defined available resource itemTypes. String: " .. itemType)
        return false
    end

    if not validation:validateEventPartLength(itemId, false) then
        logger:w("Validation fail - resource event - itemId: Cannot be (null), empty or above 64 characters. String: " .. itemId)
        return false
    end

    if not validation:validateEventPartCharacters(itemId) then
        logger:w("Validation fail - resource event - itemId: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " .. itemId)
        return false
    end

    return true
end

function validation:validateProgressionEvent(progressionStatusValues, progressionStatus, progression01, progression02, progression03)
    if progressionStatus ~= progressionStatusValues.Start and progressionStatus ~= progressionStatusValues.Complete and progressionStatus ~= progressionStatusValues.Fail then
        logger:w("Validation fail - progression event: Invalid progression status " .. tostring(progressionStatus))
        return false
    end

    -- Make sure progressions are defined as either 01, 01+02 or 01+02+03
    if not utilities:isStringNullOrEmpty(progression03) and not (not utilities:isStringNullOrEmpty(progression02) or utilities:isStringNullOrEmpty(progression01)) then
        logger:w("Validation fail - progression event: 03 found but 01+02 are invalid. Progression must be set as either 01, 01+02 or 01+02+03.")
        return false
    elseif not utilities:isStringNullOrEmpty(progression02) and utilities:isStringNullOrEmpty(progression01) then
        logger:w("Validation fail - progression event: 02 found but not 01. Progression must be set as either 01, 01+02 or 01+02+03")
        return false
    elseif utilities:isStringNullOrEmpty(progression01) then
        logger:w("Validation fail - progression event: progression01 not valid. Progressions must be set as either 01, 01+02 or 01+02+03")
        return false
    end

    -- progression01 (required)
    if not validation:validateEventPartLength(progression01, false) then
        logger:w("Validation fail - progression event - progression01: Cannot be (null), empty or above 64 characters. String: " .. progression01)
        return false
    end

    if not validation:validateEventPartCharacters(progression01) then
        logger:w("Validation fail - progression event - progression01: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " .. progression01)
        return false
    end

    -- progression02
    if not utilities:isStringNullOrEmpty(progression02) then
        if not validation:validateEventPartLength(progression02, false) then
            logger:w("Validation fail - progression event - progression02: Cannot be empty or above 64 characters. String: " .. progression02)
            return false
        end

        if not validation:validateEventPartCharacters(progression02) then
            logger:w("Validation fail - progression event - progression02: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " .. progression02)
            return false
        end
    end

    -- progression03
    if not utilities:isStringNullOrEmpty(progression03) then
        if not validation:validateEventPartLength(progression03, false) then
            logger:w("Validation fail - progression event - progression03: Cannot be empty or above 64 characters. String: " .. progression03)
            return false
        end

        if not validation:validateEventPartCharacters(progression03) then
            logger:w("Validation fail - progression event - progression03: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " .. progression03)
            return false
        end
    end

    return true
end

function validation:validateEventIdLength(eventId)
    if utilities:isStringNullOrEmpty(eventId) then
        return false
    end

    local count = 0
    for s in string.gmatch(eventId, "([^:]+)") do
        count = count + 1
        if count > 5 then
            return false
        end
        if #s > 64 then
            return false
        end
    end

    return true
end

function validation:validateEventIdCharacters(eventId)
    if utilities:isStringNullOrEmpty(eventId) then
        return false
    end

    local count = 0
    for s in string.gmatch(eventId, "([^:]+)") do
        count = count + 1
        if count > 5 then
            return false
        end
        if not string.find(s, "^[A-Za-z0-9%s%-_%.%(%)!%?]+$") then
            return false
        end
    end

    return true
end

function validation:validateDesignEvent(eventId)
    if not validation:validateEventIdLength(eventId) then
        logger:w("Validation fail - design event - eventId: Cannot be (null) or empty. Only 5 event parts allowed seperated by :. Each part need to be 32 characters or less. String: " .. eventId)
        return false
    end

    if not validation:validateEventIdCharacters(eventId) then
        logger:w("Validation fail - design event - eventId: Non valid characters. Only allowed A-z, 0-9, -_., ()!?. String: " .. eventId)
        return false
    end

    -- value: allow 0, negative and nil (not required)
    return true
end

function validation:validateLongString(longString, canBeEmpty)
    -- String is allowed to be empty
    if canBeEmpty and utilities:isStringNullOrEmpty(longString) then
        return true
    end

    if utilities:isStringNullOrEmpty(longString) or #longString > 8192 then
        return false
    end

    return true
end

function validation:validateErrorEvent(severityValues, severity, message)
    if severity ~= severityValues.debug and severity ~= severityValues.info and severity ~= severityValues.warning and severity ~= severityValues.error and severity ~= severityValues.critical then
        logger:w("Validation fail - error event - severity: Severity was unsupported value " .. tostring(severity))
        return false
    end

    if not validation:validateLongString(message, true) then
        logger:w("Validation fail - error event - message: Message cannot be above 8192 characters.")
        return false
    end

    return true
end

return validation
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
            </Item>
            <Item class="ModuleScript" referent="RBX14584cc0d6704a73828d545fa96d87a7">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">Threading</string>
                    <string name="ScriptGuid"></string>
                    <ProtectedString name="Source"><![CDATA[local threading = {
    _canSafelyClose = true,
    _endThread = false,
    _isRunning = false,
    _blocks = {},
    _scheduledBlock = nil,
    _hasScheduledBlockRun = true
}

local logger = require(script.Parent.Logger)
local RunService = game:GetService("RunService")

local function getScheduledBlock()
    local now = tick()

    if not threading._hasScheduledBlockRun and threading._scheduledBlock ~= nil and threading._scheduledBlock.deadline <= now then
        threading._hasScheduledBlockRun = true
        return threading._scheduledBlock
    else
        return nil
    end
end

local function run()

    spawn(function()
        logger:d("Starting GA thread")

        while not threading._endThread do
            threading._canSafelyClose = false

            if #threading._blocks ~= 0 then
                for _,b in pairs(threading._blocks) do
                    pcall(function()
                        b.block()
                    end)
                end
                threading._blocks = {}
            end

            local timedBlock = getScheduledBlock()
            if timedBlock ~= nil then
                pcall(function()
                    timedBlock.block()
                end)
            end

            threading._canSafelyClose = true

            wait(1)
        end

        logger:d("GA thread stopped")
    end)

    --Safely Close
    game:BindToClose(function()

        -- waiting bug fix to work inside studio
        if RunService:IsStudio() then
            return
        end
        --Give game.Players.PlayerRemoving time to to its thang
        wait(1)

        --Delay
        if not threading._canSafelyClose then
            repeat
                wait()
            until threading._canSafelyClose
        end
        wait(3)
    end)
end

function threading:scheduleTimer(interval, callback)
    if self._endThread then
        return
    end

    if not self._isRunning then
        self._isRunning = true
        run()
    end

    local timedBlock = {
        block = callback,
        deadline = tick() + interval
    }

    if self._hasScheduledBlockRun then
        self._scheduledBlock = timedBlock
        self._hasScheduledBlockRun = false
    end
end

function threading:performTaskOnGAThread(callback)
    if self._endThread then
        return
    end

    if not self._isRunning then
        self._isRunning = true
        run()
    end

    local timedBlock = {
        block = callback,
    }

    self._blocks[#self._blocks + 1] = timedBlock
end

function threading:stopThread()
    self._endThread = true
end

return threading
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
            </Item>
            <Item class="ModuleScript" referent="RBX99cd668c174048349f2ece6db3c8afd4">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">GAErrorSeverity</string>
                    <string name="ScriptGuid"></string>
                    <ProtectedString name="Source"><![CDATA[local function readonlytable(table)
   return setmetatable({}, {
     __index = table,
     __newindex = function(t, k, v)
                    error("Attempt to modify read-only table: " .. t .. ", key=" .. k .. ", value=" .. v)
                  end,
     __metatable = false
   });
end

return readonlytable({
    debug = "debug";
    info = "info";
    warning = "warning";
    error = "error";
    critical = "critical";
})
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
            </Item>
            <Item class="ModuleScript" referent="RBX9a762c40155746f09057ee57f778235c">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">GAProgressionStatus</string>
                    <string name="ScriptGuid"></string>
                    <ProtectedString name="Source"><![CDATA[local function readonlytable(table)
   return setmetatable({}, {
     __index = table,
     __newindex = function(t, k, v)
                    error("Attempt to modify read-only table: " .. t .. ", key=" .. k .. ", value=" .. v)
                  end,
     __metatable = false
   });
end

return readonlytable({
    Start = "Start";
    Complete = "Complete";
    Fail = "Fail";
})
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
            </Item>
            <Item class="ModuleScript" referent="RBXeaa8109bf36e45c987ef4664347edc33">
                <Properties>
                    <Content name="LinkedSource"><null></null></Content>
                    <string name="Name">GAResourceFlowType</string>
                    <string name="ScriptGuid"></string>
                    <ProtectedString name="Source"><![CDATA[local function readonlytable(table)
   return setmetatable({}, {
     __index = table,
     __newindex = function(t, k, v)
                    error("Attempt to modify read-only table: " .. t .. ", key=" .. k .. ", value=" .. v)
                  end,
     __metatable = false
   });
end

return readonlytable({
    Source = "Source";
    Sink = "Sink";
})
]]></ProtectedString>
                    <BinaryString name="Tags"></BinaryString>
                </Properties>
            </Item>
        </Item>
    </Item>
</roblox>
